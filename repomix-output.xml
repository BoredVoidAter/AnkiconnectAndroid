This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/workflows/android-release.yml
.gitignore
app/.gitignore
app/build.gradle
app/proguard-rules.pro
app/schemas/com.kamwithk.ankiconnectandroid.routing.database.EntriesDatabase/1.json
app/src/androidTest/java/com/kamwithk/ankiconnectandroid/ExampleInstrumentedTest.java
app/src/main/AndroidManifest.xml
app/src/main/java/com/kamwithk/ankiconnectandroid/ankidroid_api/BinaryFile.java
app/src/main/java/com/kamwithk/ankiconnectandroid/ankidroid_api/DeckAPI.java
app/src/main/java/com/kamwithk/ankiconnectandroid/ankidroid_api/IntegratedAPI.java
app/src/main/java/com/kamwithk/ankiconnectandroid/ankidroid_api/MediaAPI.java
app/src/main/java/com/kamwithk/ankiconnectandroid/ankidroid_api/ModelAPI.java
app/src/main/java/com/kamwithk/ankiconnectandroid/ankidroid_api/NoteAPI.java
app/src/main/java/com/kamwithk/ankiconnectandroid/ankidroid_api/Utility.java
app/src/main/java/com/kamwithk/ankiconnectandroid/MainActivity.java
app/src/main/java/com/kamwithk/ankiconnectandroid/request_parsers/MediaRequest.java
app/src/main/java/com/kamwithk/ankiconnectandroid/request_parsers/NoteRequest.java
app/src/main/java/com/kamwithk/ankiconnectandroid/request_parsers/Parser.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/AnkiAPIRouting.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/APIHandler.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/database/AudioFileEntry.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/database/AudioFileEntryDao.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/database/EntriesDatabase.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/database/Entry.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/database/EntryDao.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/ForvoAPIRouting.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/LocalAudioAPIRouting.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/LocalAudioRouteHandler.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/localaudiosource/ForvoAudioSource.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/localaudiosource/JPodAltAudioSource.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/localaudiosource/JPodAudioSource.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/localaudiosource/LocalAudioSource.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/localaudiosource/NHK16AudioSource.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/localaudiosource/Shinmeikai8AudioSource.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/RouteHandler.java
app/src/main/java/com/kamwithk/ankiconnectandroid/routing/Router.java
app/src/main/java/com/kamwithk/ankiconnectandroid/Scraper.java
app/src/main/java/com/kamwithk/ankiconnectandroid/Service.java
app/src/main/java/com/kamwithk/ankiconnectandroid/SettingsActivity.java
app/src/main/res/drawable-v24/ic_launcher_foreground.xml
app/src/main/res/drawable/app_launcher_foreground.xml
app/src/main/res/drawable/ic_baseline_settings_24.xml
app/src/main/res/drawable/ic_launcher_background.xml
app/src/main/res/layout/activity_main.xml
app/src/main/res/layout/settings_activity.xml
app/src/main/res/menu/toolbar_menu.xml
app/src/main/res/mipmap-anydpi-v26/app_launcher_round.xml
app/src/main/res/mipmap-anydpi-v26/app_launcher.xml
app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
app/src/main/res/values-night/themes.xml
app/src/main/res/values/app_launcher_background.xml
app/src/main/res/values/arrays.xml
app/src/main/res/values/colors.xml
app/src/main/res/values/strings.xml
app/src/main/res/values/themes.xml
app/src/main/res/xml/file_provider_paths.xml
app/src/main/res/xml/root_preferences.xml
app/src/test/java/com/kamwithk/ankiconnectandroid/ExampleUnitTest.java
build.gradle
docs/api.md
gradle.properties
gradle/wrapper/gradle-wrapper.properties
gradlew
gradlew.bat
LICENSE
README.md
settings.gradle
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/.gitignore">
/build
</file>

<file path="app/proguard-rules.pro">
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
</file>

<file path="app/src/androidTest/java/com/kamwithk/ankiconnectandroid/ExampleInstrumentedTest.java">
package com.kamwithk.ankiconnectandroid;

import android.content.Context;
import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.ext.junit.runners.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

import static org.junit.Assert.*;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {
    @Test
    public void useAppContext() {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
        assertEquals("com.kamwithk.ankiconnectandroid", appContext.getPackageName());
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/ankidroid_api/DeckAPI.java">
package com.kamwithk.ankiconnectandroid.ankidroid_api;

import android.content.Context;
import com.ichi2.anki.api.AddContentApi;

import java.util.HashMap;
import java.util.Map;

public class DeckAPI {
    private final AddContentApi api;

    public DeckAPI(Context context) {
        api = new AddContentApi(context);
    }

    public String[] deckNames() throws Exception {
        Map<Long, String> decks = api.getDeckList();

        if (decks != null) {
            return decks.values().toArray(new String[0]);
        } else {
            throw new Exception("Couldn't get deck names");
        }
    }

    public Map<String, Long> deckNamesAndIds() throws Exception {
        Map<Long, String> temporary = api.getDeckList();
        Map<String, Long> decks = new HashMap<>();

        if (temporary != null) {
            // Reverse hashmap to get entries of (Name, ID)
            for (Map.Entry<Long, String> entry : temporary.entrySet()) {
                decks.put(entry.getValue(), entry.getKey());
            }

            return decks;
        } else {
            throw new Exception("Couldn't get deck names and IDs");
        }
    }

    public Long getDeckID(String name) throws Exception {
        for (Map.Entry<String, Long> entry : deckNamesAndIds().entrySet()) {
            if (entry.getKey().equalsIgnoreCase(name)) {
                return entry.getValue();
            }
        }

        // Can't find deck
        throw new Exception("Couldn't get deck ID");
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/ankidroid_api/ModelAPI.java">
package com.kamwithk.ankiconnectandroid.ankidroid_api;

import android.content.Context;
import com.ichi2.anki.api.AddContentApi;

import java.util.HashMap;
import java.util.Map;

public class ModelAPI {
    private final AddContentApi api;

    public ModelAPI(Context context) {
        api = new AddContentApi(context);
    }

    public String[] modelNames() throws Exception {
        Map<Long, String> models = api.getModelList(0);

        if (models != null) {
            return models.values().toArray(new String[0]);
        } else {
            throw new Exception("Couldn't get model names");
        }
    }

    public Map<String, Long> modelNamesAndIds(Integer numFields) throws Exception {
        Map<Long, String> temporary = api.getModelList(numFields);
        Map<String, Long> models = new HashMap<>();

        if (temporary != null) {
            // Reverse hashmap to get entries of (Name, ID)
            for (Map.Entry<Long, String> entry : temporary.entrySet()) {
                models.put(entry.getValue(), entry.getKey());
            }

            return models;
        } else {
            throw new Exception("Couldn't get models names and IDs");
        }
    }

    public String[] modelFieldNames(Long model_id) {
        return api.getFieldList(model_id);
    }

    public Long getModelID(String modelName, Integer numFields) throws Exception {
        Map<String, Long> modelList = modelNamesAndIds(numFields);
        for (Map.Entry<String, Long> entry : modelList.entrySet()) {
            if (entry.getKey().equals(modelName)) {
                return entry.getValue(); // first model wins
            }
        }

        // Can't find model
        throw new Exception("Couldn't get model ID");
    }
}
</file>

<file path="app/src/main/res/drawable-v24/ic_launcher_foreground.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:aapt="http://schemas.android.com/aapt"
        android:width="108dp"
        android:height="108dp"
        android:viewportWidth="108"
        android:viewportHeight="108">
    <path
            android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                    android:startY="49.59793"
                    android:startX="42.9492"
                    android:endY="92.4963"
                    android:endX="85.84757"
                    android:type="linear">
                <item
                        android:color="#44000000"
                        android:offset="0.0"/>
                <item
                        android:color="#00000000"
                        android:offset="1.0"/>
            </gradient>
        </aapt:attr>
    </path>
    <path
            android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
            android:fillColor="#FFFFFF"
            android:fillType="nonZero"
            android:strokeWidth="1"
            android:strokeColor="#00000000"/>
</vector>
</file>

<file path="app/src/main/res/drawable/app_launcher_foreground.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108"
    android:tint="#000000">
  <group android:scaleX="2.3298244"
      android:scaleY="2.3298244"
      android:translateX="26.042107"
      android:translateY="25.524368">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M5,16c0,3.87 3.13,7 7,7s7,-3.13 7,-7v-4L5,12v4zM16.12,4.37l2.1,-2.1 -0.82,-0.83 -2.3,2.31C14.16,3.28 13.12,3 12,3s-2.16,0.28 -3.09,0.75L6.6,1.44l-0.82,0.83 2.1,2.1C6.14,5.64 5,7.68 5,10v1h14v-1c0,-2.32 -1.14,-4.36 -2.88,-5.63zM9,9c-0.55,0 -1,-0.45 -1,-1s0.45,-1 1,-1 1,0.45 1,1 -0.45,1 -1,1zM15,9c-0.55,0 -1,-0.45 -1,-1s0.45,-1 1,-1 1,0.45 1,1 -0.45,1 -1,1z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_baseline_settings_24.xml">
<vector android:height="24dp" android:tint="#FFFFFF"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M19.14,12.94c0.04,-0.3 0.06,-0.61 0.06,-0.94c0,-0.32 -0.02,-0.64 -0.07,-0.94l2.03,-1.58c0.18,-0.14 0.23,-0.41 0.12,-0.61l-1.92,-3.32c-0.12,-0.22 -0.37,-0.29 -0.59,-0.22l-2.39,0.96c-0.5,-0.38 -1.03,-0.7 -1.62,-0.94L14.4,2.81c-0.04,-0.24 -0.24,-0.41 -0.48,-0.41h-3.84c-0.24,0 -0.43,0.17 -0.47,0.41L9.25,5.35C8.66,5.59 8.12,5.92 7.63,6.29L5.24,5.33c-0.22,-0.08 -0.47,0 -0.59,0.22L2.74,8.87C2.62,9.08 2.66,9.34 2.86,9.48l2.03,1.58C4.84,11.36 4.8,11.69 4.8,12s0.02,0.64 0.07,0.94l-2.03,1.58c-0.18,0.14 -0.23,0.41 -0.12,0.61l1.92,3.32c0.12,0.22 0.37,0.29 0.59,0.22l2.39,-0.96c0.5,0.38 1.03,0.7 1.62,0.94l0.36,2.54c0.05,0.24 0.24,0.41 0.48,0.41h3.84c0.24,0 0.44,-0.17 0.47,-0.41l0.36,-2.54c0.59,-0.24 1.13,-0.56 1.62,-0.94l2.39,0.96c0.22,0.08 0.47,0 0.59,-0.22l1.92,-3.32c0.12,-0.22 0.07,-0.47 -0.12,-0.61L19.14,12.94zM12,15.6c-1.98,0 -3.6,-1.62 -3.6,-3.6s1.62,-3.6 3.6,-3.6s3.6,1.62 3.6,3.6S13.98,15.6 12,15.6z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_launcher_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<vector
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:height="108dp"
        android:width="108dp"
        android:viewportHeight="108"
        android:viewportWidth="108">
    <path android:fillColor="#3DDC84"
          android:pathData="M0,0h108v108h-108z"/>
    <path android:fillColor="#00000000" android:pathData="M9,0L9,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,0L19,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,0L29,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,0L39,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,0L49,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,0L59,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,0L69,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,0L79,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M89,0L89,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M99,0L99,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,9L108,9"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,19L108,19"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,29L108,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,39L108,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,49L108,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,59L108,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,69L108,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,79L108,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,89L108,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,99L108,99"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,29L89,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,39L89,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,49L89,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,59L89,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,69L89,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,79L89,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,19L29,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,19L39,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,19L49,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,19L59,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,19L69,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,19L79,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
</vector>
</file>

<file path="app/src/main/res/layout/settings_activity.xml">
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <com.google.android.material.appbar.MaterialToolbar
        android:id="@+id/settingsToolbar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="?attr/colorPrimaryVariant"
        android:minHeight="?attr/actionBarSize"
        android:theme="?attr/actionBarTheme"
        style="@style/MyToolbar"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        />

    <FrameLayout
        android:id="@+id/settings"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:layout_constraintTop_toBottomOf="@+id/settingsToolbar" />
</androidx.constraintlayout.widget.ConstraintLayout>
</file>

<file path="app/src/main/res/menu/toolbar_menu.xml">
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    tools:context=".activity.MainActivity">

    <item android:id="@+id/action_settings"
        android:title="@string/action_settings"
        android:icon="@drawable/ic_baseline_settings_24"
        app:showAsAction="ifRoom"/>
</menu>
</file>

<file path="app/src/main/res/mipmap-anydpi-v26/app_launcher_round.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/app_launcher_background"/>
    <foreground android:drawable="@drawable/app_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="app/src/main/res/mipmap-anydpi-v26/app_launcher.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/app_launcher_background"/>
    <foreground android:drawable="@drawable/app_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@drawable/ic_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@drawable/ic_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="app/src/main/res/values-night/themes.xml">
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Theme.AnkiconnectAndroid" parent="Theme.MaterialComponents.DayNight.NoActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/purple_200</item>
        <item name="colorPrimaryVariant">@color/purple_700</item>
        <item name="colorOnPrimary">@color/black</item>
        <!-- Secondary brand color. -->
        <item name="colorSecondary">@color/teal_200</item>
        <item name="colorSecondaryVariant">@color/teal_200</item>
        <item name="colorOnSecondary">@color/black</item>
        <!-- Status bar color. -->
        <item name="android:statusBarColor" tools:targetApi="l">?attr/colorPrimaryVariant</item>
        <!-- Customize your theme here. -->
    </style>

</resources>
</file>

<file path="app/src/main/res/values/app_launcher_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="app_launcher_background">#2AA99E</color>
</resources>
</file>

<file path="app/src/main/res/values/colors.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
</resources>
</file>

<file path="app/src/main/res/values/themes.xml">
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Theme.AnkiconnectAndroid" parent="Theme.MaterialComponents.DayNight.NoActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/purple_500</item>
        <item name="colorPrimaryVariant">@color/purple_700</item>
        <item name="colorOnPrimary">@color/white</item>
        <!-- Secondary brand color. -->
        <item name="colorSecondary">@color/teal_200</item>
        <item name="colorSecondaryVariant">@color/teal_700</item>
        <item name="colorOnSecondary">@color/black</item>
        <!-- Status bar color. -->
        <item name="android:statusBarColor" tools:targetApi="l">?attr/colorPrimaryVariant</item>
        <!-- Customize your theme here. -->

    </style>
    <style name="MyToolbar">
        <item name="titleTextColor">@color/white</item>
        <!-- trying to change the back button on light mode to black: neither work??? -->
        <!--item name="colorControlNormal">@color/white</item>-->
        <!--android:homeAsUpIndicator="@drawable/ic_baseline_arrow_back_24"-->
    </style>
</resources>
</file>

<file path="app/src/main/res/xml/file_provider_paths.xml">
<paths>
    <cache-path name="cache" path="/" />
    <files-path name="files" path="/" />
    <external-cache-path name="external-cache" path="/"/>
</paths>
</file>

<file path="app/src/test/java/com/kamwithk/ankiconnectandroid/ExampleUnitTest.java">
package com.kamwithk.ankiconnectandroid;

import org.junit.Test;

import static org.junit.Assert.*;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {
    @Test
    public void addition_isCorrect() {
        assertEquals(4, 2 + 2);
    }
}
</file>

<file path="LICENSE">
GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.
</file>

<file path=".gitignore">
*.iml
.gradle
/local.properties
.idea/
/.idea/caches
/.idea/libraries
/.idea/modules.xml
/.idea/workspace.xml
/.idea/navEditor.xml
/.idea/assetWizardSettings.xml
.DS_Store
/build
/captures
.externalNativeBuild
.cxx
local.properties
*.log
*.apk
output.json
misc.xml
deploymentTargetDropDown.xml
render.experimental.xml
*.jks
*.keystore
*.hprof
app/src/main/jniLibs/
</file>

<file path="app/schemas/com.kamwithk.ankiconnectandroid.routing.database.EntriesDatabase/1.json">
{
  "formatVersion": 1,
  "database": {
    "version": 1,
    "identityHash": "5d87bb1994094115b2328fad2f85b427",
    "entities": [
      {
        "tableName": "entries",
        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` INTEGER NOT NULL, `expression` TEXT NOT NULL, `reading` TEXT, `source` TEXT NOT NULL, `speaker` TEXT, `display` TEXT, `file` TEXT NOT NULL, PRIMARY KEY(`id`))",
        "fields": [
          {
            "fieldPath": "id",
            "columnName": "id",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "expression",
            "columnName": "expression",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "reading",
            "columnName": "reading",
            "affinity": "TEXT",
            "notNull": false
          },
          {
            "fieldPath": "source",
            "columnName": "source",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "speaker",
            "columnName": "speaker",
            "affinity": "TEXT",
            "notNull": false
          },
          {
            "fieldPath": "display",
            "columnName": "display",
            "affinity": "TEXT",
            "notNull": false
          },
          {
            "fieldPath": "file",
            "columnName": "file",
            "affinity": "TEXT",
            "notNull": true
          }
        ],
        "primaryKey": {
          "autoGenerate": false,
          "columnNames": [
            "id"
          ]
        },
        "indices": [
          {
            "name": "idx_all",
            "unique": false,
            "columnNames": [
              "expression",
              "reading",
              "source"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `idx_all` ON `${TABLE_NAME}` (`expression`, `reading`, `source`)"
          },
          {
            "name": "idx_reading_speaker",
            "unique": false,
            "columnNames": [
              "expression",
              "reading",
              "speaker"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `idx_reading_speaker` ON `${TABLE_NAME}` (`expression`, `reading`, `speaker`)"
          },
          {
            "name": "idx_expr_reading",
            "unique": false,
            "columnNames": [
              "expression",
              "reading"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `idx_expr_reading` ON `${TABLE_NAME}` (`expression`, `reading`)"
          },
          {
            "name": "idx_speaker",
            "unique": false,
            "columnNames": [
              "speaker"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `idx_speaker` ON `${TABLE_NAME}` (`speaker`)"
          },
          {
            "name": "idx_reading",
            "unique": false,
            "columnNames": [
              "reading"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `idx_reading` ON `${TABLE_NAME}` (`reading`)"
          }
        ],
        "foreignKeys": []
      },
      {
        "tableName": "android",
        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` INTEGER NOT NULL, `file` TEXT NOT NULL, `source` TEXT NOT NULL, `data` BLOB NOT NULL, PRIMARY KEY(`id`))",
        "fields": [
          {
            "fieldPath": "id",
            "columnName": "id",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "file",
            "columnName": "file",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "source",
            "columnName": "source",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "data",
            "columnName": "data",
            "affinity": "BLOB",
            "notNull": true
          }
        ],
        "primaryKey": {
          "autoGenerate": false,
          "columnNames": [
            "id"
          ]
        },
        "indices": [
          {
            "name": "idx_android",
            "unique": false,
            "columnNames": [
              "file",
              "source"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `idx_android` ON `${TABLE_NAME}` (`file`, `source`)"
          }
        ],
        "foreignKeys": []
      }
    ],
    "views": [],
    "setupQueries": [
      "CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)",
      "INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42, '5d87bb1994094115b2328fad2f85b427')"
    ]
  }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/ankidroid_api/BinaryFile.java">
package com.kamwithk.ankiconnectandroid.ankidroid_api;

/** A binary file whose contents have been read into memory */
public class BinaryFile {
    private String filename;
    private byte[] data;

    public String getFilename() {
        return filename;
    }

    public void setFilename(String filename) {
        this.filename = filename;
    }

    public byte[] getData() {
        return data;
    }

    public void setData(byte[] data) {
        this.data = data;
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/ankidroid_api/Utility.java">
package com.kamwithk.ankiconnectandroid.ankidroid_api;

import android.text.Html;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public final class Utility {

    private static Pattern STYLE_PATTERN = Pattern.compile("(?s)<style.*?>.*?</style>");
    private static Pattern SCRIPT_PATTERN = Pattern.compile("(?s)<script.*?>.*?</script>");
    private static Pattern TAG_PATTERN = Pattern.compile("<.*?>");
    private static Pattern IMG_PATTERN = Pattern.compile("<img src=[\"']?([^\"'>]+)[\"']? ?/?>");
    private static Pattern HTML_ENTITIES_PATTERN = Pattern.compile("&#?\\w+;");
    private static final String FIELD_SEPARATOR = Character.toString('\u001f');

    private Utility() {
    }

    // taken from AnkiDroid
    public static String[] splitTags(String tags) {
        if (tags == null) {
            return null;
        }
        return tags.trim().split("\\s+");
    }

    public static String[] splitFields(String fields) {
        return fields != null? fields.split(FIELD_SEPARATOR, -1): null;
    }

    public static long getFieldChecksum(String data) {
        final String SHA1_ZEROES =  "0000000000000000000000000000000000000000";
        String strippedData = stripHTMLMedia(data);

        try {
            MessageDigest md = MessageDigest.getInstance("SHA1");
            byte[] digest = md.digest(strippedData.getBytes(StandardCharsets.UTF_8));
            BigInteger bigInteger = new BigInteger(1, digest);
            String result = bigInteger.toString(16);

            if(result.length() < 40) {
                result = SHA1_ZEROES.substring(0, SHA1_ZEROES.length() - result.length()) + result;
            }
            return Long.valueOf(result.substring(0, 8), 16);
        }
        catch (Exception e) {
            throw new IllegalStateException("Error making field checksum with SHA1 algorithm and UTF-8 encoding", e);
        }
    }

    private static String stripHTMLMedia(String s) {
        Matcher imgMatcher = IMG_PATTERN.matcher(s);
        return stripHTML(imgMatcher.replaceAll(" $1 "));
    }

    private static String stripHTML(String s) {
        Matcher htmlMatcher = STYLE_PATTERN.matcher(s);
        String strRep = htmlMatcher.replaceAll("");
        htmlMatcher = SCRIPT_PATTERN.matcher(strRep);
        strRep = htmlMatcher.replaceAll("");
        htmlMatcher = TAG_PATTERN.matcher(strRep);
        strRep = htmlMatcher.replaceAll("");
        return entsToTxt(strRep);
    }

    private static String entsToTxt(String html) {
        String htmlReplaced = html.replace("&nbsp;", " ");
        Matcher htmlEntities = HTML_ENTITIES_PATTERN.matcher(htmlReplaced);
        StringBuffer sb = new StringBuffer();
        while (htmlEntities.find()) {
            htmlEntities.appendReplacement(sb, Html.fromHtml(htmlEntities.group()).toString());
        }
        htmlEntities.appendTail(sb);
        return sb.toString();
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/request_parsers/MediaRequest.java">
package com.kamwithk.ankiconnectandroid.request_parsers;

import android.util.Base64;

import androidx.annotation.NonNull;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Simple class that encodes the media passed into an addNote, updateNoteFields, etc request.
 * Currently very limited; only supports the type, data, filename, and fields[] part of the request.
 */
public class MediaRequest {
    private final MediaType mediaType;
    private final String filename;
    private final ArrayList<String> fields;

    private Optional<byte[]> data = Optional.empty();
    private Optional<String> url = Optional.empty();

    public enum MediaType {
        AUDIO,
        VIDEO,
        PICTURE,
    }

    public MediaRequest(MediaType mediaType, String filename, ArrayList<String> fields) {
        this.mediaType = mediaType;
        this.filename = filename;
        this.fields = fields;
    }

    public MediaType getMediaType() {
        return mediaType;
    }
    
    public String getFilename() {
        return filename;
    }

    public List<String> getFields() {
        return fields;
    }

    public Optional<byte[]> getData() {
        return data;
    }

    public void setData(byte[] data) {
        this.data = Optional.of(data);
    }

    public void setUrl(String url) {
        this.url = Optional.of(url);
    }
    public Optional<String> getUrl() {
        return url;
    }



    @NonNull
    public static MediaRequest fromJson(JsonElement mediaFile, MediaType mediaType) {
        // This is the expected format of the mediaFile:
        // {
        //  "url": "https://www.example.com/audio.mp3",
        //  "filename": "audio_自転車_2023-03-24T15:39:17.151Z",
        //  "fields": [
        //    "Audio"
        //  ]
        // }
        JsonObject mediaObject = mediaFile.getAsJsonObject();

        String filename = mediaObject.get("filename").getAsString();
        JsonArray fields = mediaObject.get("fields").getAsJsonArray();

        // convert fields to String[]
        ArrayList<String> fieldsList = new ArrayList<>();
        for (int i = 0; i < fields.size(); i++) {
            fieldsList.add(fields.get(i).getAsString());
        }

        MediaRequest request = new MediaRequest(mediaType, filename, fieldsList);

        if (mediaObject.has("url")) {
            request.setUrl(mediaObject.get("url").getAsString());
        }

        if (mediaObject.has("data")) {
            request.setData(Base64.decode(mediaObject.get("data").getAsString(), Base64.DEFAULT));
        }

        return request;
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/request_parsers/NoteRequest.java">
package com.kamwithk.ankiconnectandroid.request_parsers;

import androidx.annotation.NonNull;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;

import java.util.ArrayList;
import java.util.List;

public class NoteRequest {

    public static class NoteOptions {
        private final boolean allowDuplicate;

        private final String duplicateScope;

        private final String deckName;

        private final boolean checkChildren;

        private final boolean checkAllModels;

        public NoteOptions(boolean allowDuplicate,
                           String duplicateScope,
                           String deckName,
                           boolean checkChildren,
                           boolean checkAllModels) {
            this.allowDuplicate = allowDuplicate;
            this.duplicateScope = duplicateScope;
            this.deckName = deckName;
            this.checkChildren = checkChildren;
            this.checkAllModels = checkAllModels;
        }

        public boolean isAllowDuplicate() {
            return allowDuplicate;
        }

        public String getDuplicateScope() {
            return duplicateScope;
        }

        public String getDeckName() {
            return deckName;
        }

        public boolean isCheckChildren() {
            return checkChildren;
        }

        public boolean isCheckAllModels() {
            return checkAllModels;
        }
    }

    private final String fieldName;
    private final String fieldValue;
    private final String modelName;

    private final String deckName;

    private final List<String> tags;

    private final NoteOptions options;

    public NoteRequest(String fieldName, String fieldValue, String modelName, String deckName, List<String> tags, NoteOptions options) {
        this.fieldName = fieldName;
        this.fieldValue = fieldValue;
        this.modelName = modelName;
        this.deckName = deckName;
        this.tags = tags;
        this.options = options;
    }

    public String getFieldName() {
        return fieldName;
    }

    public String getFieldValue() {
        return fieldValue;
    }

    public String getModelName() {
        return modelName;
    }

    public String getDeckName() {
        return deckName;
    }

    public List<String> getTags() {
        return tags;
    }

    public NoteOptions getOptions() {
        return options;
    }

    @NonNull
    public static NoteRequest fromJson(JsonElement noteElement) {
        ArrayList<String> tagList = new ArrayList<>();
        JsonObject noteObject = noteElement.getAsJsonObject();

        JsonObject fieldsObject = noteObject.get("fields").getAsJsonObject();
        String field = fieldsObject.keySet().toArray()[0].toString();
        String value = fieldsObject.get(field).getAsString();

        String modelName = noteObject.get("modelName").getAsString();
        String deckName = noteObject.get("deckName").getAsString();

        JsonArray jsonTags = noteElement.getAsJsonObject().get("tags").getAsJsonArray();
        for (JsonElement tag : jsonTags) {
            tagList.add(tag.getAsString());
        }

        NoteOptions options = null;
        if (noteObject.has("options")) {
            options = readNoteOptions(noteObject.get("options").getAsJsonObject());
        }

        return new NoteRequest(field,
                value,
                modelName,
                deckName,
                tagList,
                options);
    }

    @NonNull
    private static NoteOptions readNoteOptions(JsonObject optionsObject) {
        boolean allowDuplicate = false;
        String duplicateScope = null;
        String duplicateScopeDeckName = null;
        boolean duplicateScopeCheckChildren = false;
        boolean duplicateScopeCheckAllModels = false;


        allowDuplicate = optionsObject.get("allowDuplicate").getAsBoolean();
        duplicateScope = optionsObject.get("duplicateScope").getAsString();
        if (optionsObject.has("duplicateScopeOptions")) {
            JsonObject duplicateScopeObject = optionsObject.get("duplicateScopeOptions").getAsJsonObject();

            if (duplicateScopeObject.has("deckName")) {
                JsonElement duplicateDeckName =  duplicateScopeObject.get("deckName");
                if(!duplicateDeckName.isJsonNull()) {
                    duplicateScopeDeckName = duplicateDeckName.getAsString();
                }
            }
            if (duplicateScopeObject.has("deckName")) {
                duplicateScopeCheckChildren = duplicateScopeObject.get("checkChildren").getAsBoolean();
            }
            if (duplicateScopeObject.has("deckName")) {
                duplicateScopeCheckAllModels = duplicateScopeObject.get("checkAllModels").getAsBoolean();
            }
        }

        return new NoteOptions(allowDuplicate,
                duplicateScope,
                duplicateScopeDeckName,
                duplicateScopeCheckChildren,
                duplicateScopeCheckAllModels);
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/database/EntryDao.java">
package com.kamwithk.ankiconnectandroid.routing.database;

import androidx.room.Dao;
import androidx.room.RawQuery;
import androidx.sqlite.db.SupportSQLiteQuery;

import java.util.List;

@Dao
public interface EntryDao {
    // https://stackoverflow.com/questions/44287465/how-to-dynamically-query-the-room-database-at-runtime
    @RawQuery
    List<Entry> getSources(SupportSQLiteQuery query);
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/ForvoAPIRouting.java">
package com.kamwithk.ankiconnectandroid.routing;

import android.content.Context;
import android.util.Log;
import com.google.gson.JsonObject;
import com.google.gson.reflect.TypeToken;
import com.kamwithk.ankiconnectandroid.Scraper;
import com.kamwithk.ankiconnectandroid.request_parsers.Parser;
import fi.iki.elonen.NanoHTTPD;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;

public class ForvoAPIRouting {
    private final Scraper scraper;

    public ForvoAPIRouting(Context context) {
        scraper = new Scraper(context);
    }

//    Term can also be named expression (older versions)
    private String getTerm(List<String> term, List<String> expression) {
        try {
            return term.get(0);
        } catch (NullPointerException e) {
            return expression.get(0);
        }
    }

    public NanoHTTPD.Response getAudio(String word, String reading) throws IOException {
        ArrayList<HashMap<String, String>> audio_sources = scraper.scrape(word, reading);

        Type typeToken = new TypeToken<ArrayList<HashMap<String, String>>>() {}.getType();

        JsonObject response = new JsonObject();
        response.addProperty("type", "audioSourceList");
        response.add("audioSources", Parser.gson.toJsonTree(audio_sources, typeToken));

        return newFixedLengthResponse(
                NanoHTTPD.Response.Status.OK,
                "text/json",
                Parser.gson.toJson(response)
        );
    }

    public NanoHTTPD.Response getAudioHandleError(List<String> term, List<String> expression, String reading) {
        try {
            return getAudio(getTerm(term, expression), reading);
        } catch (IOException e) {
            Log.d("Error Scraping", e.toString());

            Map<String, String> response = new HashMap<>();
            response.put("result", null);
            response.put("error", e.toString());

            return newFixedLengthResponse(NanoHTTPD.Response.Status.OK, "text/json", Parser.gson.toJson(response));
        }
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/localaudiosource/Shinmeikai8AudioSource.java">
package com.kamwithk.ankiconnectandroid.routing.localaudiosource;

import com.kamwithk.ankiconnectandroid.routing.database.Entry;

public class Shinmeikai8AudioSource extends LocalAudioSource {
    public Shinmeikai8AudioSource() {
        super("shinmeikai8", "user_files/shinmeikai8_files");
    }

    @Override
    public String getSourceName(Entry entry) {
        return "SMK8 " + entry.display;
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/Service.java">
package com.kamwithk.ankiconnectandroid;

import android.annotation.SuppressLint;
import android.app.Notification;
import android.app.PendingIntent;
import android.content.Intent;
import android.os.IBinder;
import android.util.Log;
import androidx.annotation.Nullable;
import androidx.core.app.NotificationCompat;
import com.kamwithk.ankiconnectandroid.routing.Router;

import java.io.IOException;

import static com.kamwithk.ankiconnectandroid.MainActivity.CHANNEL_ID;

public class Service extends android.app.Service {
    public static final int PORT = 8765;

    private Router server;

    @Override
    public void onCreate() { // Only one time
        super.onCreate();

        try {
            server = new Router(PORT, this);
        } catch (IOException e) {
            Log.w("Httpd", "The Server was unable to start");
            e.printStackTrace();
        }
    }

    @SuppressLint("UnspecifiedImmutableFlag")
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) { // Every time start is called
        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = null;
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {
            pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);
        } else {
            pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, PendingIntent.FLAG_UPDATE_CURRENT);
        }

        Notification notification = new NotificationCompat.Builder(this, CHANNEL_ID)
                .setContentTitle("Ankiconnect Android")
                .setSmallIcon(R.mipmap.app_launcher)
                .setContentIntent(pendingIntent)
                .setOngoing(true)
                .build();

        startForeground(1, notification);

        return START_STICKY;
    }

    @Override
    public void onDestroy() {
        server.stop();
        super.onDestroy();
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
}
</file>

<file path="app/src/main/res/layout/activity_main.xml">
<?xml version="1.0" encoding="utf-8"?>


<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity">

    <com.google.android.material.appbar.MaterialToolbar
        android:id="@+id/materialToolbar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="?attr/colorPrimaryVariant"
        android:minHeight="?attr/actionBarSize"
        android:theme="?attr/actionBarTheme"
        style="@style/MyToolbar"
        app:layout_constraintTop_toTopOf="parent"
        tools:layout_editor_absoluteX="16dp" />

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/materialToolbar">

        <LinearLayout
            android:id="@+id/linearLayout"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:gravity="center"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:id="@+id/text_message"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Ankiconnect Android"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintLeft_toLeftOf="parent"
                app:layout_constraintRight_toRightOf="parent"
                app:layout_constraintTop_toTopOf="parent" />

            <Button
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:onClick="startServiceBtn"
                android:text="Start Service" />

            <Button
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:onClick="stopServiceBtn"
                android:text="Stop Service" />


        </LinearLayout>
    </androidx.constraintlayout.widget.ConstraintLayout>


</androidx.constraintlayout.widget.ConstraintLayout>
</file>

<file path="app/src/main/res/values/arrays.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="forvo_language_entries">
        <item>Arabic (ar)</item>
        <item>German (de)</item>
        <item>English (en)</item>
        <item>Spanish (es)</item>
        <item>French (fr)</item>
        <item>Ancient Greek (grc)</item>
        <item>Hungarian (hu)</item>
        <item>Italian (it)</item>
        <item>Japanese (ja)</item>
        <item>Korean (ko)</item>
        <item>Dutch (nl)</item>
        <item>Polish (pl)</item>
        <item>Portuguese (pt)</item>
        <item>Russian (ru)</item>
        <item>Swedish (sv)</item>
        <item>Turkish (tr)</item>
        <item>Tatar (tt)</item>
        <item>Ukrainian (uk)</item>
        <item>Cantonese (yue)</item>
        <item>Mandarin Chinese (zh)</item>
    </string-array>

    <string-array name="forvo_language_values">
        <item>ar</item>
        <item>de</item>
        <item>en</item>
        <item>es</item>
        <item>fr</item>
        <item>grc</item>
        <item>hu</item>
        <item>it</item>
        <item>ja</item>
        <item>ko</item>
        <item>nl</item>
        <item>pl</item>
        <item>pt</item>
        <item>ru</item>
        <item>sv</item>
        <item>tr</item>
        <item>tt</item>
        <item>uk</item>
        <item>yue</item>
        <item>zh</item>
    </string-array>
</resources>
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="settings.gradle">
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.PREFER_SETTINGS)
    repositories {
        google()
        mavenCentral()
        maven { url "https://jitpack.io" }
    }
}
rootProject.name = "Ankiconnect Android"
include ':app'
</file>

<file path=".github/workflows/android-release.yml">
name: Android Release

on:
  push:
    branches:
      - master

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        distribution: 'temurin'
        java-version: '17'
        cache: 'gradle'

    - name: Setup Gradle
      uses: gradle/gradle-build-action@v2

    - name: Build with Gradle
      run: ./gradlew assembleRelease
      env:
        SIGNING_KEY_STORE_BASE64: ${{ secrets.SIGNING_KEY_STORE_BASE64 }}
        SIGNING_KEY_ALIAS: ${{ secrets.SIGNING_KEY_ALIAS }}
        SIGNING_KEY_PASSWORD: ${{ secrets.SIGNING_KEY_PASSWORD }}
        SIGNING_STORE_PASSWORD: ${{ secrets.SIGNING_STORE_PASSWORD }}

    - name: Create Release and Upload APK
      uses: "marvinpinto/action-automatic-releases@latest"
      with:
        repo_token: "${{ secrets.GITHUB_TOKEN }}"
        automatic_release_tag: "latest"
        prerelease: false
        files: |
          app/build/outputs/apk/release/app-release.apk
</file>

<file path="app/src/main/AndroidManifest.xml">
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <!--
        This permission is required to open another activity from an app in the background
        (i.e. AnkiConnectAndroid opening AnkiDroid when the kiwi browser is in focus)
        NOTE: https://developer.android.com/reference/android/Manifest.permission#SYSTEM_ALERT_WINDOW
        > Very few apps should use this permission; these windows are intended for
        > system-level interaction with the user.
    -->
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />

    <queries>
        <package android:name="com.ichi2.anki" />
    </queries>

    <application
        android:allowBackup="true"
        android:icon="@mipmap/app_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/app_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.AnkiconnectAndroid">
        <activity
            android:name=".SettingsActivity"
            android:exported="false"
            android:parentActivityName=".MainActivity"
            android:label="@string/action_settings">
            <meta-data
                android:name="android.app.lib_name"
                android:value="" />
        </activity>
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_provider_paths" />
        </provider>

        <service android:name=".Service" />
    </application>

</manifest>
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/MainActivity.java">
package com.kamwithk.ankiconnectandroid;

import static android.Manifest.permission.POST_NOTIFICATIONS;

import android.app.Dialog;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Toast;
import androidx.appcompat.app.AppCompatActivity;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.widget.Toolbar;
import androidx.core.content.ContextCompat;
import androidx.fragment.app.DialogFragment;

import com.kamwithk.ankiconnectandroid.ankidroid_api.IntegratedAPI;


public class MainActivity extends AppCompatActivity {

    public static class NotificationsPermissionDialogFragment extends DialogFragment {
        @NonNull
        @Override
        public Dialog onCreateDialog(Bundle savedInstanceState) {
            // Use the Builder class for convenient dialog construction
            MainActivity activity = (MainActivity) getActivity();
            AlertDialog.Builder builder = new AlertDialog.Builder(activity);
            builder.setMessage(R.string.dialog_notif_perm_info)
                    .setPositiveButton("Ok", new DialogInterface.OnClickListener() {
                        public void onClick(DialogInterface dialog, int id) {
                            // ASSUMPTION: NotificationsPermissionDialogFragment is only created
                            // on API level >= 33
                            activity.requestPermissionLauncher.launch(POST_NOTIFICATIONS);
                        }
                    })
                    .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
                        public void onClick(DialogInterface dialog, int id) {
                            activity.startServiceWithoutNotifications();
                        }
                    });
            // Create the AlertDialog object and return it
            return builder.create();
        }
    }

    public static final String CHANNEL_ID = "ankiConnectAndroid";
    private NotificationManager notificationManager;
    private ActivityResultLauncher<String> requestPermissionLauncher;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // toolbar support
        Toolbar toolbar = findViewById(R.id.materialToolbar);
        setSupportActionBar(toolbar);

        IntegratedAPI.authenticate(this);

        NotificationChannel notificationChannel = new NotificationChannel(CHANNEL_ID, "Ankiconnect Android", NotificationManager.IMPORTANCE_DEFAULT);
        notificationManager = getSystemService(NotificationManager.class);
        notificationManager.createNotificationChannel(notificationChannel);

        // this cannot be put inside attemptGrantNotifyPermissions, because it is called by
        // a onClickListener and crashes the app: https://stackoverflow.com/a/67582633
        requestPermissionLauncher =
                registerForActivityResult(new ActivityResultContracts.RequestPermission(), isGranted -> {
                    if (!isGranted) {
                        Toast.makeText(this, "Attempting to start server without notification...", Toast.LENGTH_LONG).show();
                    }
                    startService();
                });
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.toolbar_menu, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        int id = item.getItemId();
        if (id == R.id.action_settings) {
            // open settings
            Intent intent = new Intent(MainActivity.this, SettingsActivity.class);
            startActivity(intent);
            return true;
        } else {
            return super.onOptionsItemSelected(item);
        }
    }

    public void attemptGrantNotificationPermissions() {
        // Register the permissions callback, which handles the user's response to the
        // system permissions dialog. Save the return value, an instance of
        // ActivityResultLauncher, as an instance variable.

        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {
            // there's nothing else we can do on older SDK versions
            startServiceWithoutNotifications();
            return;
        }

        // NOTE: I can't find anything about this in the actual documentation, but an
        // explanation for shouldShowRequestPermissionRationale is shown below
        // (taken from: https://stackoverflow.com/a/39739972):
        //
        // This method returns true if the app has requested this permission previously and the
        // user denied the request. Note: If the user turned down the permission request in the
        // past and chose the Don't ask again option in the permission request system dialog,
        // this method returns false.
        if (shouldShowRequestPermissionRationale(POST_NOTIFICATIONS)) {
            // Explain that notifications are "needed" to display the server
            new NotificationsPermissionDialogFragment().show(this.getSupportFragmentManager(), "post_notifications_dialog");
        } else {
            // Directly ask for the permission.
            requestPermissionLauncher.launch(POST_NOTIFICATIONS);
        }

    }

    public void startServiceWithoutNotifications() {
        Toast.makeText(this, "Attempting to start server without notification...", Toast.LENGTH_LONG).show();
        startService();
    }

    public void startService() {
        Intent serviceIntent = new Intent(this, Service.class);
        ContextCompat.startForegroundService(this, serviceIntent);
    }


    public void startServiceBtn(View view) {
        boolean notificationsEnabled = notificationManager.areNotificationsEnabled();
        if (notificationsEnabled) {
            startService();
        } else {
            attemptGrantNotificationPermissions();
        }
    }

    public void stopServiceBtn(View view) {
        Intent serviceIntent = new Intent(this, Service.class);
        stopService(serviceIntent);
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/database/AudioFileEntry.java">
package com.kamwithk.ankiconnectandroid.routing.database;

import androidx.annotation.NonNull;
import androidx.room.ColumnInfo;
import androidx.room.Entity;
import androidx.room.Index;
import androidx.room.PrimaryKey;

@Entity(tableName = "android",
    indices= {
        @Index(name="idx_android", value = {"file", "source"}),
    }
)
public class AudioFileEntry {
    @PrimaryKey
    public int id;

    @NonNull
    @ColumnInfo(name = "file")
    public String file;

    @NonNull
    @ColumnInfo(name = "source")
    public String source;

    @NonNull
    @ColumnInfo(typeAffinity = ColumnInfo.BLOB, name = "data")
    public byte[] data;
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/database/AudioFileEntryDao.java">
package com.kamwithk.ankiconnectandroid.routing.database;

import androidx.room.Dao;
import androidx.room.Query;

@Dao
public interface AudioFileEntryDao {
    @Query("SELECT data FROM android WHERE file = :file AND source = :source")
    public byte[] getData(String file, String source);
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/database/Entry.java">
package com.kamwithk.ankiconnectandroid.routing.database;

import androidx.annotation.NonNull;
import androidx.room.ColumnInfo;
import androidx.room.Entity;
import androidx.room.Index;
import androidx.room.PrimaryKey;

@Entity(tableName = "entries",
    indices= { // TODO remove some indices?
        @Index(name="idx_all", value = {"expression", "reading", "source"}),

        @Index(name="idx_reading_speaker", value = {"expression", "reading", "speaker"}),

        @Index(name="idx_expr_reading", value = {"expression", "reading"}),

        @Index(name="idx_speaker", value = {"speaker"}),

        @Index(name="idx_reading", value = {"reading"}),
    }
)
public class Entry {
    @PrimaryKey
    //@NonNull
    @ColumnInfo(name = "id")
    public int id;

    @NonNull
    @ColumnInfo(name = "expression")
    public String expression;

    @ColumnInfo(name = "reading")
    public String reading;

    @NonNull
    @ColumnInfo(name = "source")
    public String source;

    @ColumnInfo(name = "speaker")
    public String speaker;

    @ColumnInfo(name = "display")
    public String display;

    @NonNull
    @ColumnInfo(name = "file")
    public String file;
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/Scraper.java">
package com.kamwithk.ankiconnectandroid;

import android.content.Context;
import android.content.SharedPreferences;
import android.util.Base64;

import androidx.preference.PreferenceManager;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

// Regular expressions and method source - https://github.com/jamesnicolas/yomichan-forvo-server
public class Scraper {
    private final Context context;
    private final String SERVER_HOST = "https://forvo.com";
    private final String AUDIO_HTTP_HOST = "https://audio00.forvo.com";
    private final String DEFAULT_FORVO_LANGUAGE = "ja";

    public Scraper(Context context) {
        this.context = context;
    }

    public ArrayList<HashMap<String, String>> scrape(String word, String reading) throws IOException {
        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
        String forvoLanguage = preferences.getString("forvo_language", DEFAULT_FORVO_LANGUAGE);

        ArrayList<HashMap<String, String>> audio_sources = scrapeWord(word, forvoLanguage);

//        Get similar words audio if exact word isn't found
        if (audio_sources.size() == 0) {
            audio_sources = scrapeWord(reading, forvoLanguage);
        }
        if (audio_sources.size() == 0) {
            audio_sources = scrapeSearch(word, forvoLanguage);
        }
        if (audio_sources.size() == 0) {
            audio_sources = scrapeSearch(reading, forvoLanguage);
        }

        return audio_sources;
    }

    private ArrayList<HashMap<String, String>> scrapeWord(String word, String language) throws IOException {
        Document document = Jsoup.connect(SERVER_HOST + "/word/" + strip(word) + "/").get();
        Elements elements = document.select("#language-container-" + language + ">article>ul>li:not(.li-ad)");

        ArrayList<HashMap<String, String>> audio_sources = new ArrayList<>();

        for (Element element : elements) {
            //System.out.println(element);
            String url = extractURL(Objects.requireNonNull(element.selectFirst(".play")));

            HashMap<String, String> user_details = new HashMap<>();
            user_details.put("name", "Forvo (" + extractUsername(element.text()) + ")");
            user_details.put("url", url);
            audio_sources.add(user_details);
        }

        return audio_sources;
    }

    private ArrayList<HashMap<String, String>> scrapeSearch(String input, String language) throws IOException {
        Document document = Jsoup.connect(SERVER_HOST + "/search/" + strip(input) + "/" + language + "/").get();
        Elements elements = document.select("ul.word-play-list-icon-size-l>li>.play");

        ArrayList<HashMap<String, String>> audio_sources = new ArrayList<>();

        for (Element element : elements) {
            HashMap<String, String> user_details = new HashMap<>();
            user_details.put("name", "Forvo Search");
            user_details.put("url", extractURL(element));
            audio_sources.add(user_details);
        }

        return audio_sources;
    }

//    Helper method to get rid of leading/trailing spaces
    private String strip(String input) {
        return input.replaceAll("^[ \t]+|[ \t]+$", "");
    }

    @SuppressWarnings("ResultOfMethodCallIgnored")
    private String extractURL(Element span) {
        String play = span.attr("onclick");

        Pattern pattern = Pattern.compile("([^',\\(\\)]+)");
        Matcher m = pattern.matcher(play);

//        Go to third occurrence
        m.find();
        m.find();
        m.find();

        String file = new String(Base64.decode(m.group(), Base64.DEFAULT), StandardCharsets.UTF_8);
        return AUDIO_HTTP_HOST + "/mp3/" + file;
    }

    @SuppressWarnings("ResultOfMethodCallIgnored")
    private String extractUsername(String text) {
        Pattern pattern = Pattern.compile("Pronunciation by([^(]+)\\(");
        Matcher matcher = pattern.matcher(strip(text));
        matcher.find();

        return strip(Objects.requireNonNull(matcher.group(1)));
    }
}
</file>

<file path="build.gradle">
// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.10.1'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        google()
        mavenCentral()
        maven { url "https://jitpack.io" }
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</file>

<file path="gradle.properties">
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app"s APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Automatically convert third-party libraries to use AndroidX
android.enableJetifier=true
# Speed up development by using a cache
org.gradle.unsafe.configuration-cache=true
android.defaults.buildfeatures.buildconfig=true
android.nonTransitiveRClass=false
android.nonFinalResIds=false
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd "${APP_HOME:-./}" > /dev/null && pwd -P ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/ankidroid_api/MediaAPI.java">
package com.kamwithk.ankiconnectandroid.ankidroid_api;

import android.annotation.SuppressLint;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.util.Log;
import androidx.core.content.FileProvider;
import com.kamwithk.ankiconnectandroid.BuildConfig;
import com.ichi2.anki.FlashCardsContract;
import com.ichi2.anki.api.AddContentApi;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;

public class MediaAPI {
    private Context context;
    private final AddContentApi api;

    public MediaAPI(Context context) {
        this.context = context;
        api = new AddContentApi(context);
    }

    /**
     * Stores the given file and returns its name, without the initial slash.
     */
    @SuppressLint("SetWorldReadable")
    public String storeMediaFile(String filename, byte[] data) throws IOException {
        // TODO: investigate why filename gets a number attached to it, i.e. file.png -> file_123456789.png
        String lastPathSegment = Uri.parse(filename).getLastPathSegment();
        lastPathSegment = lastPathSegment == null ? filename : lastPathSegment;
        File file = new File(context.getCacheDir(), lastPathSegment);

//        Write to a temporary file
        try (FileOutputStream fileOutputStream = new FileOutputStream(file)) {
            fileOutputStream.write(data);
        } catch (Exception e) {
            Log.w("Error", e);
            throw e;
        }

        Uri file_uri = FileProvider.getUriForFile(context, BuildConfig.APPLICATION_ID, file);
        context.grantUriPermission("com.ichi2.anki", file_uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);

        ContentValues contentValues = new ContentValues();
        contentValues.put(FlashCardsContract.AnkiMedia.FILE_URI, file_uri.toString());
        contentValues.put(FlashCardsContract.AnkiMedia.PREFERRED_NAME, lastPathSegment.replaceAll("\\..*", ""));

        ContentResolver contentResolver = context.getContentResolver();
        Uri returnUri = contentResolver.insert(FlashCardsContract.AnkiMedia.CONTENT_URI, contentValues);

//        Remove temporary file
        file.deleteOnExit();

        return new File(returnUri.getPath()).toString().substring(1);
    }

    /**
     * Download the requested audio file from the internet and store it on the disk.
     * @return The path to the audio file.
     */
    public String downloadAndStoreBinaryFile(String fileName, String url) throws IOException {
        byte[] data = downloadMediaFile(url);
        BinaryFile binaryFile = new BinaryFile();
        binaryFile.setFilename(fileName);
        binaryFile.setData(data);

        return storeMediaFile(binaryFile.getFilename(), binaryFile.getData());
    }

    public byte[] downloadMediaFile(String audioUri) throws IOException {
        URL url = new URL(audioUri);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();

        try (InputStream in = conn.getInputStream()) {
            try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {
                byte[] buffer = new byte[1024 * 5];
                int bytesRead;
                while ((bytesRead = in.read(buffer)) != -1) {
                    out.write(buffer, 0, bytesRead);
                }
                byte[] data = out.toByteArray();
                return data;
            }
        }
    }

}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/database/EntriesDatabase.java">
package com.kamwithk.ankiconnectandroid.routing.database;

import androidx.room.Database;
import androidx.room.RoomDatabase;

@Database(entities = {Entry.class, AudioFileEntry.class}, version = 1)
public abstract class EntriesDatabase extends RoomDatabase {
    public abstract EntryDao entryDao();
    public abstract AudioFileEntryDao audioFileEntryDao();
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/LocalAudioRouteHandler.java">
package com.kamwithk.ankiconnectandroid.routing;

import static fi.iki.elonen.NanoHTTPD.MIME_PLAINTEXT;
import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;

import android.content.Context;

import java.util.Map;

import fi.iki.elonen.NanoHTTPD;
import fi.iki.elonen.router.RouterNanoHTTPD;


public class LocalAudioRouteHandler extends RouterNanoHTTPD.DefaultHandler {
    private LocalAudioAPIRouting routing = null;

    public LocalAudioRouteHandler() {
        super();
    }

    @Override
    public String getText() {
        return "not implemented";
    }

    @Override
    public String getMimeType() {
        return "text/json";
    }

    @Override
    public NanoHTTPD.Response.IStatus getStatus() {
        return NanoHTTPD.Response.Status.OK;
    }

    public NanoHTTPD.Response get(RouterNanoHTTPD.UriResource uriResource, Map<String, String> urlParams, NanoHTTPD.IHTTPSession session) {
        // setup ???
        // TODO this looks like a hack (same with the main handler!)
        if (routing == null) {
            Context context = uriResource.initParameter(0, Context.class); // ???
            routing = new LocalAudioAPIRouting(context);
        }

        String uri = session.getUri();
        if (uri.equals("/localaudio/get/")) { // get sources
            return routing.getAudioSourcesHandleError(session.getParameters());
        }

        // otherwise, it's getting the actual audio file instead
        // the uri should be of the format: /localaudio/SOURCE/FILE_NAME
        // components should be: ["", "localaudio", SOURCE, FILE_NAME]
        String[] uriComponents = uri.split("/", 4);
        if (uriComponents.length != 4) {
            return newFixedLengthResponse(NanoHTTPD.Response.Status.BAD_REQUEST, MIME_PLAINTEXT, "Invalid uri: " + uri);
        }
        return routing.getAudioHandleError(uriComponents[2], uriComponents[3]);
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/Router.java">
package com.kamwithk.ankiconnectandroid.routing;

import android.content.Context;
import fi.iki.elonen.NanoHTTPD;
import fi.iki.elonen.router.RouterNanoHTTPD;

import java.io.IOException;

public class Router extends RouterNanoHTTPD {
    private Context context;
    public static String contentType;

    public Router(Integer port, Context context) throws IOException {
        super(port);
        this.context = context;

        contentType = new ContentType("; charset=UTF-8").getContentTypeHeader();
        addMappings();
        start(NanoHTTPD.SOCKET_READ_TIMEOUT, false);
    }

    public void setContext(Context context) {
        this.context = context;
    }

    @Override
    public void addMappings() {
        addRoute("/", RouteHandler.class, this.context);
        addRoute("/localaudio/(.)+", LocalAudioRouteHandler.class, this.context);
        // for some reason, none of these work, so the above is used instead
        // addRoute("/localaudio/:source/(.)+", LocalAudioRouteHandler.class, this.context);
        // addRoute("/localaudio/:source/:file", LocalAudioRouteHandler.class, this.context);
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/SettingsActivity.java">
package com.kamwithk.ankiconnectandroid;

import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.provider.Settings;
import android.widget.Toast;

import androidx.appcompat.app.ActionBar;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.Toolbar;
import androidx.preference.EditTextPreference;
import androidx.preference.Preference;
import androidx.preference.PreferenceFragmentCompat;


public class SettingsActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.settings_activity);
        if (savedInstanceState == null) {
            getSupportFragmentManager()
                    .beginTransaction()
                    .replace(R.id.settings, new SettingsFragment())
                    .commit();
        }

        Toolbar settingsToolbar = findViewById(R.id.settingsToolbar);
        setSupportActionBar(settingsToolbar);

        ActionBar actionBar = getSupportActionBar();
        if (actionBar != null) {
            // adds back button
            actionBar.setDisplayHomeAsUpEnabled(true);
        }
    }

    public static class SettingsFragment extends PreferenceFragmentCompat {
        @Override
        public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
            setPreferencesFromResource(R.xml.root_preferences, rootKey);

            Preference preference = findPreference("access_overlay_perms");
            if (preference != null) {
                // custom handler of preference: open permissions screen
                preference.setOnPreferenceClickListener(p -> {
                    Intent permIntent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);
                    startActivity(permIntent);
                    return true;
                });

            }

            preference = findPreference("get_dir_path");
            if (preference != null) {
                // custom handler of preference: open permissions screen
                preference.setOnPreferenceClickListener(p -> {

                    Context context = getContext();
                    if (context == null) {
                        Toast.makeText(getContext(), "Cannot get local audio folder, as context is null.", Toast.LENGTH_LONG).show();
                    } else {
                        Toast.makeText(getContext(), "Local audio folder: " + context.getExternalFilesDir(null), Toast.LENGTH_LONG).show();
                        // TODO snackbar?
                        // getView() seems to be null...
//                        Snackbar snackbar = Snackbar.make(getView().findViewById(R.id.settings),
//                                "Local audio folder: " + context.getExternalFilesDir(null),
//                                BaseTransientBottomBar.LENGTH_LONG);
//                        snackbar.show();
                    }
                    return true;
                });

            }

           EditTextPreference corsHostPreference = findPreference("cors_hostname");
           if (corsHostPreference != null) {
                corsHostPreference.setOnBindEditTextListener(editText -> editText.setHint("e.g. http://example.com"));            }
        }
    }


}
</file>

<file path="app/src/main/res/values/strings.xml">
<resources>
    <string name="app_name">Ankiconnect Android</string>

    <string name="action_settings">Settings</string>
    <string name="settings_overlay_permissions_title">Access Overlay Permissions</string>
    <string name="settings_permissions_header">Permissions</string>
    <string name="settings_overlay_permissions_summary">Allows Ankiconnect Android to open AnkiDroid\'s card browser.</string>
    <string name="settings_other_header">Other</string>
    <string name="settings_forvo_language_title">Forvo language</string>
    <string name="settings_forvo_language_summary">Sets the language to use for Forvo audio.</string>
    <string name="settings_forvo_language_dialog_title">Select Language</string>
    <string name="get_dir_path_title">Print Local Audio Directory</string>
    <string name="get_dir_path_title_summary">Prints the expected directory path where the local audio is searched in.</string>
    <string name="dialog_notif_perm_info">This app uses a persistent notification to inform you that the server is running. Please enable notifications to see this.</string>
</resources>
</file>

<file path="app/src/main/res/xml/root_preferences.xml">
<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <PreferenceCategory app:title="@string/settings_permissions_header">

        <Preference
            app:key="access_overlay_perms"
            app:title="@string/settings_overlay_permissions_title"
            app:summary="@string/settings_overlay_permissions_summary" />

    </PreferenceCategory>

    <PreferenceCategory
        android:title="Access from other sites"
        app:summary="Allow access from an external site">

        <EditTextPreference
            app:dialogMessage="Enter the hostname you want to allow access from."
            app:dialogTitle="Enter CORS Host"
            app:key="cors_host"
            app:title="CORS Host"
            app:useSimpleSummaryProvider="true" />

    </PreferenceCategory>

    <PreferenceCategory app:title="@string/settings_other_header">

        <ListPreference
            app:key="forvo_language"
            app:title="@string/settings_forvo_language_title"
            app:summary="@string/settings_forvo_language_summary"
            android:dialogTitle="@string/settings_forvo_language_dialog_title"
            android:defaultValue="ja"
            android:entries="@array/forvo_language_entries"
            android:entryValues="@array/forvo_language_values" />

        <Preference
            app:key="get_dir_path"
            app:title="@string/get_dir_path_title"
            app:summary="@string/get_dir_path_title_summary" />

    </PreferenceCategory>
</PreferenceScreen>
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/request_parsers/Parser.java">
package com.kamwithk.ankiconnectandroid.request_parsers;

import android.util.Base64;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class Parser {
    public static Gson gson = new GsonBuilder().setPrettyPrinting().serializeNulls().create();
    public static Gson gsonNoSerialize = new GsonBuilder().setPrettyPrinting().create();

    public static JsonObject parse(String raw_data) {
        return JsonParser.parseString(raw_data).getAsJsonObject();
    }

    public static String get_action(JsonObject data) {
        return data.get("action").getAsString();
    }

    public static int get_version(JsonObject data, int fallback) {
        if (data.has("version")) {
            return data.get("version").getAsInt();
        }
        return fallback;
    }

    public static String getDeckName(JsonObject raw_data) {
        return raw_data.get("params").getAsJsonObject().get("note").getAsJsonObject().get("deckName").getAsString();
    }

    public static String getModelName(JsonObject raw_data) {
        return raw_data.get("params").getAsJsonObject().get("note").getAsJsonObject().get("modelName").getAsString();
    }

    public static String getModelNameFromParam(JsonObject raw_data) {
        return raw_data.get("params").getAsJsonObject().get("modelName").getAsString();
    }

    public static Map<String, String> getNoteValues(JsonObject raw_data) {
        Type fieldType = new TypeToken<Map<String, String>>() {}.getType();
        return gson.fromJson(raw_data.get("params").getAsJsonObject().get("note").getAsJsonObject().get("fields"), fieldType);
    }

    public static Set<String> getNoteTags(JsonObject raw_data) {
        Type fieldType = new TypeToken<Set<String>>() {}.getType();
        return gson.fromJson(raw_data.get("params").getAsJsonObject().get("note").getAsJsonObject().get("tags"), fieldType);
    }

    public static String getNoteQuery(JsonObject raw_data) {
        return raw_data.get("params").getAsJsonObject().get("query").getAsString();
    }

    public static long getUpdateNoteFieldsId(JsonObject raw_data) {
        return raw_data.get("params").getAsJsonObject().get("note").getAsJsonObject().get("id").getAsLong();
    }

    public static Map<String, String> getUpdateNoteFieldsFields(JsonObject raw_data) {
        Type fieldType = new TypeToken<Map<String, String>>() {}.getType();
        return gson.fromJson(raw_data.get("params").getAsJsonObject().get("note").getAsJsonObject().get("fields"), fieldType);
    }

    /**
     * For each key ("audio", "video", "picture"), expect EITHER a list or singular json object!
     * According to the official Anki-Connect docs:
     * > If you choose to include [audio, video, picture keys], they should contain a single object
     * > or an array of objects
     */
    public static ArrayList<MediaRequest> getNoteMediaRequests(JsonObject raw_data) {
        Map<String, MediaRequest.MediaType> media_types = Map.of(
            "audio", MediaRequest.MediaType.AUDIO,
            "video", MediaRequest.MediaType.VIDEO,
            "picture", MediaRequest.MediaType.PICTURE
        );
        JsonObject note_json = raw_data.get("params").getAsJsonObject().get("note").getAsJsonObject();

        ArrayList<MediaRequest> request_medias = new ArrayList<>();
        for (Map.Entry<String, MediaRequest.MediaType> entry: media_types.entrySet()) {
            JsonElement media_value = note_json.get(entry.getKey());
            if (media_value == null) {
                continue;
            }
            if (media_value.isJsonArray()) {
                for (JsonElement media_element: media_value.getAsJsonArray()) {
                    JsonObject media_object = media_element.getAsJsonObject();
                    MediaRequest requestMedia = MediaRequest.fromJson(media_object, entry.getValue());
                    request_medias.add(requestMedia);
                }
            } else if (media_value.isJsonObject()) {
                JsonObject media_object = media_value.getAsJsonObject();
                MediaRequest requestMedia = MediaRequest.fromJson(media_object, entry.getValue());
                request_medias.add(requestMedia);
            }
        }
        return request_medias;
    }

    /**
     * Gets the first field of the note
     */
    public static ArrayList<NoteRequest> getNoteFront(JsonObject raw_data) {
        JsonArray notes = raw_data.get("params").getAsJsonObject().get("notes").getAsJsonArray();
        ArrayList<NoteRequest> projections = new ArrayList<>();

        for (JsonElement jsonElement : notes) {
            projections.add(NoteRequest.fromJson(jsonElement));
        }

        return projections;
    }

    public static boolean[] getNoteTrues(JsonObject raw_data) {
        int num_notes = raw_data.get("params").getAsJsonObject().get("notes").getAsJsonArray().size();
        boolean[] array = new boolean[num_notes];
        Arrays.fill(array, true);

        return array;
    }

    public static ArrayList<Long> getNoteIds(JsonObject raw_data) {
        ArrayList<Long> noteIds = new ArrayList<>();
        JsonArray jsonNoteIds = raw_data.get("params").getAsJsonObject().get("notes").getAsJsonArray();
        for(JsonElement noteId: jsonNoteIds) {
            noteIds.add(noteId.getAsLong());
        }
        return noteIds;
    }

    public static String getMediaFilename(JsonObject raw_data) {
        return raw_data.get("params").getAsJsonObject().get("filename").getAsString();
    }

    public static byte[] getMediaData(JsonObject raw_data) {
        String encoded = raw_data.get("params").getAsJsonObject().get("data").getAsString();
        return Base64.decode(encoded, Base64.DEFAULT);
    }

    public static JsonArray getMultiActions(JsonObject raw_data) {
        return raw_data.get("params").getAsJsonObject().get("actions").getAsJsonArray();
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/APIHandler.java">
package com.kamwithk.ankiconnectandroid.routing;

import android.content.Context;
import android.util.Log;

import com.google.gson.JsonObject;
import com.kamwithk.ankiconnectandroid.ankidroid_api.IntegratedAPI;
import com.kamwithk.ankiconnectandroid.request_parsers.Parser;
import fi.iki.elonen.NanoHTTPD;

import java.util.*;

public class APIHandler {
    private final AnkiAPIRouting ankiAPIRouting;
    private final ForvoAPIRouting forvoAPIRouting;
    private final LocalAudioAPIRouting localAudioAPIRouting;

    public APIHandler(IntegratedAPI integratedAPI, Context context) {
        ankiAPIRouting = new AnkiAPIRouting(integratedAPI);
        forvoAPIRouting = new ForvoAPIRouting(context);
        localAudioAPIRouting = new LocalAudioAPIRouting(context);
    }

    public NanoHTTPD.Response chooseAPI(String json_string, Map<String, List<String>> parameters) {

        if ((parameters.containsKey("term") || parameters.containsKey("expression")) && parameters.containsKey("reading")) {
            String reading = Objects.requireNonNull(parameters.get("reading")).get(0);

            return forvoAPIRouting.getAudioHandleError(parameters.get("term"), parameters.get("expression"), reading);
        } else {
            Log.d("AnkiConnectAndroid", "received json: " + json_string);
            JsonObject raw_json = Parser.parse(json_string);
            return ankiAPIRouting.findRouteHandleError(raw_json);
        }
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/localaudiosource/LocalAudioSource.java">
package com.kamwithk.ankiconnectandroid.routing.localaudiosource;

import android.net.Uri;

import com.kamwithk.ankiconnectandroid.Service;
import com.kamwithk.ankiconnectandroid.routing.database.Entry;

public class LocalAudioSource {
    private final String sourceID;
    private final String mediaDir;

    public LocalAudioSource(String sourceID, String mediaDir) {
        this.sourceID = sourceID;
        this.mediaDir = mediaDir;
    }

    public String getSourceName(Entry entry) {
        return sourceID;
    }

    public String getMediaDir() {
        return mediaDir;
    }

    public String constructFileURL(String filePath) {
        Uri.Builder builder = new Uri.Builder();
        String NETLOC = "localhost:" + Service.PORT;

        builder.scheme("http")
                .encodedAuthority(NETLOC) // encoded to not escape the : character
                .appendPath("localaudio")
                .appendPath(sourceID)
                .appendPath(filePath);
        String uri = builder.build().toString();
        return uri;
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/localaudiosource/JPodAltAudioSource.java">
package com.kamwithk.ankiconnectandroid.routing.localaudiosource;

import com.kamwithk.ankiconnectandroid.routing.database.Entry;

public class JPodAltAudioSource extends LocalAudioSource {
    public JPodAltAudioSource() {
        super("jpod_alternate", "user_files/jpod_alternate_files");
    }

    @Override
    public String getSourceName(Entry entry) {
        return "JPod101 Alt";
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/localaudiosource/JPodAudioSource.java">
package com.kamwithk.ankiconnectandroid.routing.localaudiosource;

import com.kamwithk.ankiconnectandroid.routing.database.Entry;

public class JPodAudioSource extends LocalAudioSource {
    public JPodAudioSource() {
        super("jpod", "user_files/jpod_files");
    }

    @Override
    public String getSourceName(Entry entry) {
        return "JPod101";
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/RouteHandler.java">
package com.kamwithk.ankiconnectandroid.routing;

import static com.kamwithk.ankiconnectandroid.routing.Router.contentType;

import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;

import android.content.Context;
import android.content.SharedPreferences;

import androidx.preference.PreferenceManager;

import com.kamwithk.ankiconnectandroid.ankidroid_api.IntegratedAPI;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import fi.iki.elonen.NanoHTTPD;
import fi.iki.elonen.router.RouterNanoHTTPD;

public class RouteHandler extends RouterNanoHTTPD.DefaultHandler {

    private APIHandler apiHandler = null;
    private static final String PRIVATE_NETWORK_ACCESS_REQUEST = "Access-Control-Request-Private-Network";
    private static final String PRIVATE_NETWORK_ACCESS_RESPONSE = "Access-Control-Allow-Private-Network";


    public RouteHandler() {
        super();
    }

    @Override
    public String getText() {
        return "not implemented";
    }

    @Override
    public String getMimeType() {
        return "text/json";
    }

    @Override
    public NanoHTTPD.Response.IStatus getStatus() {
        return NanoHTTPD.Response.Status.OK;
    }

    public NanoHTTPD.Response get(RouterNanoHTTPD.UriResource uriResource, Map<String, String> urlParams, NanoHTTPD.IHTTPSession session) {
//        Setup
        Context context = uriResource.initParameter(0, Context.class);
        if (apiHandler == null) {
            apiHandler = new APIHandler(new IntegratedAPI(context), context);
        }

//        Enforce UTF-8 encoding (response doesn't always contain by default)
        session.getHeaders().put("content-type", contentType);

        Map<String, String> files = new HashMap<>();
        try {
            session.parseBody(files);
        } catch (IOException | NanoHTTPD.ResponseException e) {
            e.printStackTrace();
        }

        Map<String, List<String>> parameters = session.getParameters();
        if (parameters == null || parameters.isEmpty() && files.get("postData") == null) {
            // No data was provided in the POST request so we return a simple response
            NanoHTTPD.Response rep = newFixedLengthResponse("Ankiconnect Android is running.");
            addCorsHeaders(context, rep);
            return rep;
        }

        NanoHTTPD.Response rep = apiHandler.chooseAPI(files.get("postData"), parameters);

        // Include this header so that if a public origin is included in the whitelist, then browsers
        // won't fail due to the private network access check
        if (Boolean.parseBoolean(session.getHeaders().get(PRIVATE_NETWORK_ACCESS_REQUEST))) {
            rep.addHeader(PRIVATE_NETWORK_ACCESS_RESPONSE, "true");
        }

        addCorsHeaders(context, rep);
        return rep;
    }

    private void addCorsHeaders(Context context, NanoHTTPD.Response rep) {
        // Add a CORS header if it is set in the preferences
        SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
        String corsHost = sharedPreferences.getString("cors_host", "");

        if (!corsHost.trim().equals("")) {
            rep.addHeader("Access-Control-Allow-Origin", corsHost);
            rep.addHeader("Access-Control-Allow-Headers", "*");
        }
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/AnkiAPIRouting.java">
package com.kamwithk.ankiconnectandroid.routing;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.kamwithk.ankiconnectandroid.ankidroid_api.BinaryFile;
import com.kamwithk.ankiconnectandroid.ankidroid_api.DeckAPI;
import com.kamwithk.ankiconnectandroid.ankidroid_api.IntegratedAPI;
import com.kamwithk.ankiconnectandroid.ankidroid_api.MediaAPI;
import com.kamwithk.ankiconnectandroid.ankidroid_api.ModelAPI;
import com.kamwithk.ankiconnectandroid.request_parsers.NoteRequest;
import com.kamwithk.ankiconnectandroid.request_parsers.Parser;
import com.kamwithk.ankiconnectandroid.request_parsers.MediaRequest;

import fi.iki.elonen.NanoHTTPD;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;

import android.util.Log;


public class AnkiAPIRouting {
    private final IntegratedAPI integratedAPI;
    private final DeckAPI deckAPI;
    private final ModelAPI modelAPI;
    private final MediaAPI mediaAPI;

    public AnkiAPIRouting(IntegratedAPI integratedAPI) {
        this.integratedAPI = integratedAPI;
        deckAPI = integratedAPI.deckAPI;
        modelAPI = integratedAPI.modelAPI;
        mediaAPI = integratedAPI.mediaAPI;
    }

    private String findRoute(JsonObject raw_json) throws Exception {
        switch (Parser.get_action(raw_json)) {
            case "version":
                return version();
            case "deckNames":
                return deckNames();
            case "deckNamesAndIds":
                return deckNamesAndIds();
            case "modelNames":
                return modelNames();
            case "modelNamesAndIds":
                return modelNamesAndIds();
            case "modelFieldNames":
                return modelFieldNames(raw_json);
            case "findNotes":
                return findNotes(raw_json);
            case "guiBrowse":
                return guiBrowse(raw_json);
            case "canAddNotes":
                return canAddNotes(raw_json);
            case "canAddNotesWithErrorDetail":
                return canAddNotesWithErrorDetail(raw_json);
            case "addNote":
                return addNote(raw_json);
            case "addNotes":
                return addNotes(raw_json);
            case "deleteNotes":
                return deleteNotes(raw_json);
            case "updateNoteFields":
                return updateNoteFields(raw_json);
            case "updateNotes":
                return updateNotes(raw_json);
            case "storeMediaFile":
                return storeMediaFile(raw_json);
            case "notesInfo":
                return notesInfo(raw_json);
            case "multi":
                JsonArray actions = Parser.getMultiActions(raw_json);
                JsonArray results = new JsonArray();

                for (JsonElement jsonElement : actions) {
                    int version = Parser.get_version(jsonElement.getAsJsonObject(), 4);
                    String routeResult = findRoute(jsonElement.getAsJsonObject());

                    JsonElement routeResultJson = JsonParser.parseString(routeResult);
                    JsonElement response = formatSuccessReply(routeResultJson, version);
                    results.add(response);
                }

                return Parser.gson.toJson(results);
            default:
                return default_version();
        }
    }

    /* taken from anki-connect's web.py: format_success_reply */
    public JsonElement formatSuccessReply(JsonElement raw_json, int version) {
        if (version <= 4) {
            return raw_json;
        } else {
            JsonObject reply = new JsonObject();
            reply.add("result", raw_json);
            reply.add("error", null);
            return reply;
        }
    }

    public NanoHTTPD.Response findRouteHandleError(JsonObject raw_json) {
        try {
            int version = Parser.get_version(raw_json, 4);
            String response = formatSuccessReply(JsonParser.parseString(findRoute(raw_json)), version).toString();
            Log.d("AnkiConnectAndroid", "response json: " + response);
            return returnResponse(response);
        } catch (Exception e) {
            Map<String, String> response = new HashMap<>();
            response.put("result", null);

            StringWriter sw = new StringWriter();
            try {
                try (PrintWriter pw = new PrintWriter(sw)) {
                    e.printStackTrace(pw);
                }
                response.put("error", e.getMessage() + sw);
            } finally {
                try {
                    sw.close();
                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }
            return newFixedLengthResponse(NanoHTTPD.Response.Status.OK, "text/json", Parser.gson.toJson(response));
        }
    }

    private NanoHTTPD.Response returnResponse(String response) {
        return newFixedLengthResponse(NanoHTTPD.Response.Status.OK, "text/json", response);
    }

    private String version() {
        return "6";
    }

    private String default_version() {
        return "\"AnkiConnect v.6\"";
    }

    private String deckNames() throws Exception {
        return Parser.gson.toJson(deckAPI.deckNames());
    }

    private String deckNamesAndIds() throws Exception {
        return Parser.gson.toJson(deckAPI.deckNamesAndIds());
    }

    private String modelNames() throws Exception {
        return Parser.gson.toJson(modelAPI.modelNames());
    }

    private String modelNamesAndIds() throws Exception {
        return Parser.gson.toJson(modelAPI.modelNamesAndIds(0));
    }

    private String modelFieldNames(JsonObject raw_json) throws Exception {
        String model_name = Parser.getModelNameFromParam(raw_json);
        if (model_name != null && !model_name.equals("")) {
            Long model_id = modelAPI.getModelID(model_name, 0);

            return Parser.gson.toJson(modelAPI.modelFieldNames(model_id));
        } else {
            Map<String, String> response = new HashMap<>();
            response.put("result", null);
            response.put("error", "model was not found: ");

            return Parser.gson.toJson(response);
        }
    }

    private String findNotes(JsonObject raw_json) {
        return Parser.gson.toJson(integratedAPI.noteAPI.findNotes(Parser.getNoteQuery(raw_json)));
    }

    private String guiBrowse(JsonObject raw_json) {
        String query = Parser.getNoteQuery(raw_json);
        return Parser.gson.toJson(integratedAPI.guiBrowse(query));
    }

    private String canAddNotes(JsonObject raw_json) throws Exception {
        ArrayList<NoteRequest> notes_to_test = Parser.getNoteFront(raw_json);
        return Parser.gson.toJson(integratedAPI.canAddNotes(notes_to_test));
    }

    private String canAddNotesWithErrorDetail(JsonObject raw_json) throws Exception {
        ArrayList<NoteRequest> notes_to_test = Parser.getNoteFront(raw_json);
        return Parser.gsonNoSerialize.toJson(integratedAPI.canAddNotesWithErrorDetail(notes_to_test));
    }

    /**
     * Add a new note to Anki.
     * The note can include media files, which will be downloaded.
     * AnkiConnect desktop also supports other formats, but this method only supports downloadable media files.
     */
    private String addNote(JsonObject raw_json) throws Exception {
        Map<String, String> noteValues = Parser.getNoteValues(raw_json);

        ArrayList<MediaRequest> mediaRequests =
                Parser.getNoteMediaRequests(raw_json);
        integratedAPI.addMedia(noteValues, mediaRequests);

        String noteId = String.valueOf(integratedAPI.addNote(
                noteValues,
                Parser.getDeckName(raw_json),
                Parser.getModelName(raw_json),
                Parser.getNoteTags(raw_json)
        ));

        return noteId;
    }

    private String addNotes(JsonObject raw_json) throws Exception {
        JsonArray notes = raw_json.get("params").getAsJsonObject().get("notes").getAsJsonArray();
        ArrayList<Long> addedNoteIds = new ArrayList<>();

        for (JsonElement noteElement : notes) {
            JsonObject noteObject = noteElement.getAsJsonObject();

            // Create a temporary raw_json for parsing a single note, mimicking an "addNote" request structure
            JsonObject temp_raw_json = new JsonObject();
            JsonObject params = new JsonObject();
            params.add("note", noteObject);
            temp_raw_json.add("params", params);

            Map<String, String> noteValues = Parser.getNoteValues(temp_raw_json);

            ArrayList<MediaRequest> mediaRequests = Parser.getNoteMediaRequests(temp_raw_json);
            integratedAPI.addMedia(noteValues, mediaRequests);

            Long noteId = integratedAPI.addNote(
                    noteValues,
                    Parser.getDeckName(temp_raw_json),
                    Parser.getModelName(temp_raw_json),
                    Parser.getNoteTags(temp_raw_json)
            );

            if (noteId != null) {
                addedNoteIds.add(noteId);
            } else {
                addedNoteIds.add(null);
            }
        }

        return Parser.gson.toJson(addedNoteIds);
    }

    private String deleteNotes(JsonObject raw_json) throws Exception {
        ArrayList<Long> noteIds = Parser.getNoteIds(raw_json);
        long[] ids = new long[noteIds.size()];
        for (int i = 0; i < noteIds.size(); i++) {
            ids[i] = noteIds.get(i);
        }
        integratedAPI.deleteNotes(ids);
        return "null";
    }

    private String updateNoteFields(JsonObject raw_json) throws Exception {
        integratedAPI.updateNoteFields(
                Parser.getUpdateNoteFieldsId(raw_json),
                Parser.getUpdateNoteFieldsFields(raw_json),
                Parser.getNoteMediaRequests(raw_json)
        );
        return "null";
    }

    private String updateNotes(JsonObject raw_json) throws Exception {
        JsonArray notes = raw_json.get("params").getAsJsonObject().get("notes").getAsJsonArray();

        for (JsonElement noteElement : notes) {
            JsonObject noteObject = noteElement.getAsJsonObject();

            // Create a temporary raw_json for parsing a single note update
            JsonObject temp_raw_json = new JsonObject();
            JsonObject params = new JsonObject();
            params.add("note", noteObject);
            temp_raw_json.add("params", params);

            integratedAPI.updateNoteFields(
                    Parser.getUpdateNoteFieldsId(temp_raw_json),
                    Parser.getUpdateNoteFieldsFields(temp_raw_json),
                    Parser.getNoteMediaRequests(temp_raw_json)
            );
        }

        return "null";
    }

    private String storeMediaFile(JsonObject raw_json) throws Exception {
        BinaryFile binaryFile = new BinaryFile();
        binaryFile.setFilename(Parser.getMediaFilename(raw_json));
        binaryFile.setData(Parser.getMediaData(raw_json));

        return Parser.gson.toJson(integratedAPI.storeMediaFile(binaryFile));
    }

    private String notesInfo(JsonObject raw_json) throws Exception {
        ArrayList<Long> noteIds = Parser.getNoteIds(raw_json);
        return Parser.gson.toJson(integratedAPI.noteAPI.notesInfo(noteIds));
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/localaudiosource/ForvoAudioSource.java">
package com.kamwithk.ankiconnectandroid.routing.localaudiosource;

import com.kamwithk.ankiconnectandroid.routing.database.Entry;

public class ForvoAudioSource extends LocalAudioSource {
    public ForvoAudioSource() {
        super("forvo", "user_files/forvo_files");
    }

    @Override
    public String getSourceName(Entry entry)  {
        return "Forvo (" + entry.speaker + ")";
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/localaudiosource/NHK16AudioSource.java">
package com.kamwithk.ankiconnectandroid.routing.localaudiosource;

import com.kamwithk.ankiconnectandroid.routing.database.Entry;

public class NHK16AudioSource extends LocalAudioSource {
    public NHK16AudioSource() {
        super("nhk16", "user_files/nhk16_files");
    }

    @Override
    public String getSourceName(Entry entry) {
        return "NHK16 " + entry.display;
    }
}
</file>

<file path="docs/api.md">
# Actions

All actions here work exactly the same as [Anki-Connect](https://git.sr.ht/~foosoft/anki-connect#supported-actions) unless specified otherwise.

All calls support the version `<= 4` and `> 4` format.
Versions `<= 4` returns the plain result on success (with no JSON object wrapping said result).
However, versions `> 4` returns a JSON of the following format on success:
```
{
    "result": (result),
    "error": null
}
```

On error, all versions will send the following:
```
{
    "result": null,
    "error": (error)
}
```

Do not expect the error message to be the exact same as the PC Anki-Connect error messages.

<br>

## Deck Actions

### `deckNames`
* See: [Anki-Connect `deckNames`](https://git.sr.ht/~foosoft/anki-connect#codedecknamescode)
* Used by Yomichan

### `deckNamesAndIds`
* See: [Anki-Connect `deckNamesAndIds`](https://git.sr.ht/~foosoft/anki-connect#codedecknamesandidscode)
* Used by Yomichan

<br>

## Model Actions

### `modelNames`
* See: [Anki-Connect `modelNames`](https://git.sr.ht/~foosoft/anki-connect#codemodelnamescode)
* Used by Yomichan

### `modelNamesAndIds`
* See: [Anki-Connect `modelnamesandids`](https://git.sr.ht/~foosoft/anki-connect#codemodelnamesandidscode)
* Used by Yomichan

### `modelFieldNames`
* See: [Anki-Connect `modelFieldNames`](https://git.sr.ht/~foosoft/anki-connect#codemodelfieldnamescode)
* Used by Yomichan

<br>

## Note Actions

### `findNotes`
* See: [Anki-Connect `findNotes`](https://git.sr.ht/~foosoft/anki-connect#codefindnotescode)
* Attempting to escape a query with spaces using quotes will not work, unless
    AnkiDroid is using the new (Rust) backend.
    For example, the following query will not work: `"Note:My Mining Note"`
* Expect this to take longer to run compared to the PC version of Anki-Connect.
* Used by Yomichan

### `guiBrowse`
* See: [Anki-Connect `guiBrowse`](https://git.sr.ht/~foosoft/anki-connect#codeguibrowsecode)
* This call only works with AnkiDroid versions past [October 8, 2022](https://github.com/ankidroid/Anki-Android/pull/11899) (2.16alpha88 and above)
* Used by Yomichan

### `canAddNotes`
* See: [Anki-Connect `canAddNotes`](https://git.sr.ht/~foosoft/anki-connect#codecanaddnotescode)
* Internally, this behaves entirely different from Anki-Connect. Anki-Connect literally attempts to add
    a note (without saving the collection) in order to determine whether the note can be added or not.
    AnkiConnect Android instead queries the collection with the first field, and sees if any other cards
    exist.
    For example, if your first field was `Word`, `canAddNotes` determines whether a note can be added
    or not by seeing if the query `Word:(WORD FIELD CONTENTS)` finds any matches.
    Finding any match will return `false`, and no matches will return `true`.
* Because this internally queries the database, this action suffers from the same problems as `findNotes`.
    To guarantee the correctness of the query, you must use the new backend.
* If all notes have the same model, then the call is optimized as we can call an internal Ankidroid API
    function on the entire set of data.
* Used by Yomichan

### `canAddNotesWithErrorDetail`
* See: [Anki-Connect `canAddNotesWithErrorDetail](https://git.sr.ht/~foosoft/anki-connect#codecanaddnoteswitherrordetailcode)
* Currently, if a card fails `canAddNotes`, the error message will always say it's due to it being a duplicate, even if there was a different reason for the failure (For example, in Anki-Connect a card could fail the `canAddNotes` check if the first field was empty).
* Used by Yomitan

### `notesInfo`
* See: [Anki-Connect `notesInfo`](https://git.sr.ht/~foosoft/anki-connect#codenotesinfocode)
* Used by Yomitan

### `addNote`
* See: [Anki-Connect `addNote`](https://git.sr.ht/~foosoft/anki-connect#codeaddnotecode)
* Used by Yomichan
* Anki-Connect desktop allows using various formats for the media file, but this api currently only
  supports using the `url` and `data` field. Does not support `skipHash` for the `url` field.
  All of `picture`, `audio` and `video` are supported.

### `updateNoteFields`
* See: [Anki-Connect `updateNoteFields`](https://git.sr.ht/~foosoft/anki-connect#codeupdatenotefieldscode)
* See [addNote](#addnote) for supported media actions.

<br>

## Media Actions

### `storeMediaFile`
* See: [Anki-Connect `storeMediaFile`](https://git.sr.ht/~foosoft/anki-connect#codestoremediafilecode)
* Filenames will get a random number appended to the end of them, i.e. `file.png` becomes `file_123456789.png`
* Used by Yomichan

<br>

## Miscellaneous Actions

### `multi`
* See: [Anki-Connect `multi`](https://git.sr.ht/~foosoft/anki-connect#codemulticode)
* Used by Yomichan
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/ankidroid_api/NoteAPI.java">
package com.kamwithk.ankiconnectandroid.ankidroid_api;

import android.content.ContentResolver;
import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.text.TextUtils;

import com.ichi2.anki.FlashCardsContract;
import com.ichi2.anki.api.AddContentApi;

import java.util.*;

public class NoteAPI {
    private Context context;
    private final ContentResolver resolver;
    private final AddContentApi api;

    private static final String[] MODEL_PROJECTION = {FlashCardsContract.Note.MID};
    private static final String[] NOTE_ID_PROJECTION = {FlashCardsContract.Note._ID};
    private static final String[] NOTES_INFO_PROJECTION = {FlashCardsContract.Note._ID, FlashCardsContract.Note.MID, FlashCardsContract.Note.TAGS, FlashCardsContract.Note.FLDS};

    public NoteAPI(Context context) {
        this.context = context;
        this.resolver = context.getContentResolver();
        api = new AddContentApi(context);
    }

    static String escapeQueryStr(String s) {
      // first replace: \ -> \\
      // second replace: " -> \"
      return "\"" + s.replace("\\", "\\\\").replace("\"", "\\\"") + "\"";
    }

    /**
     * Add flashcards to AnkiDroid through instant add API
     *
     * @param data Map of (field name, field value) pairs
     */
    public Long addNote(final Map<String, String> data, Long deck_id, Long model_id, Set<String> tags) throws Exception {
        String[] allFieldNames = api.getFieldList(model_id);
        if (allFieldNames == null) {
            throw new Exception("Couldn't get fields");
        }

        // Get list in correct order
        String[] fields = new String[allFieldNames.length];

        for (int i = 0; i < allFieldNames.length; i++) {
            fields[i] = data.getOrDefault(allFieldNames[i], "");
        }

        return api.addNote(model_id, deck_id, fields, tags);
    }

    public String[] getNoteFields(long note_id) throws Exception {
        return api.getNote(note_id).getFields();
    }

    public boolean updateNoteFields(long note_id, final Map<String, String> data) throws Exception {
        long modelId = getNoteModelId(note_id);
        String[] allFieldNames = api.getFieldList(modelId);
        if (allFieldNames == null) {
            throw new Exception("Couldn't get fields");
        }

        // Get list in correct order
        String[] fields = new String[data.size()];
        for (int i = 0; i < data.size(); i++) {
            fields[i] = data.get(allFieldNames[i]);
        }

        return api.updateNoteFields(note_id, fields);
    }

    public Long getNoteModelId(long note_id) {
        // Manually queries the note with a specific projection to get the model ID
        // Code copied/pasted from getNote() in AddContentAPI:
        // https://github.com/ankidroid/Anki-Android/blob/1711e56c2b5515ab89c3424b60e60867bb65d492/api/src/main/java/com/ichi2/anki/api/AddContentApi.kt#L244

        Uri noteUri = Uri.withAppendedPath(FlashCardsContract.Note.CONTENT_URI, Long.toString(note_id));
        Cursor cursor = this.resolver.query(noteUri, MODEL_PROJECTION, null, null, null);

        if (cursor == null) {
            return null;
        }
        try {
            if (!cursor.moveToNext()) {
                return null;
            }
            int index = cursor.getColumnIndexOrThrow(FlashCardsContract.Note.MID);;
            return cursor.getLong(index); // mid
        } finally {
            cursor.close();
        }
    }

    public ArrayList<Long> findNotes(String query) {
        ArrayList<Long> noteIds = new ArrayList<>();

        final Cursor cursor = this.resolver.query(
                FlashCardsContract.Note.CONTENT_URI,
                NOTE_ID_PROJECTION,
                query,
                null,
                null
        );

        if (cursor != null) {
            if (!cursor.moveToFirst()) {
                return noteIds;
            }
            for (int i = 0; i < cursor.getCount(); i++) {
                long id = cursor.getLong(0);
                noteIds.add(id);
                cursor.moveToNext();
            }
            cursor.close();
        }

        return noteIds;
    }

    static class NoteInfoField {
        private final String value;
        private final int order;

        public NoteInfoField(String value, int order) {
            this.value = value;
            this.order = order;
        }

        public String getValue() {
            return value;
        }

        public int getOrder() {
            return order;
        }
    }
    static class NoteInfo {
        private final long noteId;
        private final String modelName;
        private final List<String> tags;
        private final Map<String, NoteInfoField> fields;

        public NoteInfo(long noteId, String modelName, List<String> tags, Map<String,
                NoteInfoField> fields) {
            this.noteId = noteId;
            this.modelName = modelName;
            this.tags = tags;
            this.fields = fields;
        }

        public long getNoteId() {
            return noteId;
        }

        public String getModelName() {
            return modelName;
        }

        public List<String> getTags() {
            return tags;
        }

        public Map<String, NoteInfoField> getFields() {
            return fields;
        }
    }

    static class Model {
        private final long modelId;
        private final String modelName;
        private final String[] fieldNames;

        public Model(long modelId, String modelName, String[] fieldNames) {
            this.modelId = modelId;
            this.modelName = modelName;
            this.fieldNames = fieldNames;
        }

        public long getModelId() {
            return modelId;
        }

        public String getModelName() {
            return modelName;
        }

        public String[] getFieldNames() {
            return fieldNames;
        }
    }

    public List<NoteInfo> notesInfo(ArrayList<Long> noteIds) throws Exception {
        List<NoteInfo> notesInfoList = new ArrayList<>();
        String nidQuery = "nid:" + TextUtils.join(",", noteIds);
        Map<Long, Model> cache = new HashMap<>();

        Cursor cursor = this.resolver.query(
                FlashCardsContract.Note.CONTENT_URI,
                NOTES_INFO_PROJECTION,
                nidQuery,
                null,
                null,
                null
                );

        if (cursor == null) {
            return null;
        }

        try (cursor) {
            while (cursor.moveToNext()) {

                int idIdx = cursor.getColumnIndexOrThrow(FlashCardsContract.Note._ID);
                int midIdx = cursor.getColumnIndexOrThrow(FlashCardsContract.Note.MID);
                int tagsIdx = cursor.getColumnIndexOrThrow(FlashCardsContract.Note.TAGS);
                int fldsIdx = cursor.getColumnIndexOrThrow(FlashCardsContract.Note.FLDS);

                long id = cursor.getLong(idIdx);
                long mid = cursor.getLong(midIdx);
                List<String> tags = Arrays.asList(Utility.splitTags(cursor.getString(tagsIdx)));
                String[] fieldValues = Utility.splitFields(cursor.getString(fldsIdx));
                Model model = null;

                if (cache.containsKey(mid)) {
                    model = cache.get(mid);
                }
                else {
                    String[] fieldNames = api.getFieldList(mid);
                    String modelName = api.getModelName(mid);

                    model = new Model(mid, modelName, fieldNames);
                    cache.put(mid, model);
                }

                Map<String, NoteInfoField> fields = new HashMap<>();
                String[] fieldNames = model.getFieldNames();

                for (int i = 0; i < fieldNames.length; i++) {
                    String fieldName = fieldNames[i];
                    String fieldValue = fieldValues[i];
                    NoteInfoField noteInfoField = new NoteInfoField(fieldValue, i);
                    fields.put(fieldName, noteInfoField);
                }
                NoteInfo noteInfo = new NoteInfo(id, model.getModelName(), tags, fields);
                notesInfoList.add(noteInfo);
            }
        }
        return notesInfoList;
    }
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/ankidroid_api/IntegratedAPI.java">
package com.kamwithk.ankiconnectandroid.ankidroid_api;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.net.Uri;
import android.os.Handler;
import android.os.Looper;
import android.text.TextUtils;
import android.widget.Toast;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import java.io.IOException;
import java.util.*;

import static com.ichi2.anki.api.AddContentApi.READ_WRITE_PERMISSION;

import com.kamwithk.ankiconnectandroid.request_parsers.MediaRequest;
import com.ichi2.anki.FlashCardsContract;
import com.ichi2.anki.api.AddContentApi;
import com.kamwithk.ankiconnectandroid.request_parsers.NoteRequest;

public class IntegratedAPI {
    private Context context;
    public final DeckAPI deckAPI;
    public final ModelAPI modelAPI;
    public final NoteAPI noteAPI;
    public final MediaAPI mediaAPI;
    private final AddContentApi api; // TODO: Combine all API classes???

    //From anki-connect repo
    private static final String CAN_ADD_ERROR_REASON = "cannot create note because it is a duplicate";
    public IntegratedAPI(Context context) {
        this.context = context;

        deckAPI = new DeckAPI(context);
        modelAPI = new ModelAPI(context);
        noteAPI = new NoteAPI(context);
        mediaAPI = new MediaAPI(context);

        api = new AddContentApi(context);
    }

    public static void authenticate(Context context) {
        int permission = ContextCompat.checkSelfPermission(context, READ_WRITE_PERMISSION);

        if (permission != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions((Activity)context, new String[]{READ_WRITE_PERMISSION}, 0);
        }
    }

    //public File getExternalFilesDir() {
    //    return context.getExternalFilesDir(null);
    //}

    public void addSampleCard() {
        Map<String, String> data = new HashMap<>();
        data.put("Back", "sunrise");
        data.put("Front", "日の出");

        try {
            addNote(data, "Temporary", "Basic", null);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public ArrayList<Boolean> canAddNotes(ArrayList<NoteRequest> notesToTest) throws Exception {
        final String[] NOTE_PROJECTION = {FlashCardsContract.Note._ID, FlashCardsContract.Note.CSUM};

        if(notesToTest.isEmpty()) {
            return new ArrayList<>();
        }

        ArrayList<Long> checksums = new ArrayList<>(notesToTest.size());
        ArrayList<Boolean> canAddNote = new ArrayList<>(notesToTest.size());
        NoteRequest.NoteOptions noteOptions = notesToTest.get(0).getOptions();

        // If duplicate scope is "deck" or "deck root", we need to get extra information to figure out if DID matches.
        // If duplicate scope is "deck root" we need to include children, noteOptions.getDeckName() will not be null
        HashSet<Long> deckIds = new HashSet<>();
        Map<String, Long> deckNamesToIds = deckAPI.deckNamesAndIds();
        String deckName = noteOptions.getDeckName();
        if(deckName == null) {
            // Deck, not root
            deckName = notesToTest.get(0).getDeckName();
            deckIds.add(deckNamesToIds.get(deckName));
        }
        else {
            for (String name : deckNamesToIds.keySet()) {
                if (name.contains(deckName)) {
                    deckIds.add(deckNamesToIds.get(name));
                }
            }
        }

        for (NoteRequest note : notesToTest) {
            String key = note.getFieldValue();
            checksums.add(Utility.getFieldChecksum(key));
        }

        // If duplicates are allowed, just need to see if they are valid notes (checksum != 0)
        if (noteOptions.isAllowDuplicate()) {
            for (long checksum: checksums) {
                canAddNote.add(checksum != 0);
            }
            return canAddNote;
        }

        // Grabbing the note options and model for the first note and assuming the rest are the same.
        // This is true for yomitan but might not be for other applications.
        String modelName = notesToTest.get(0).getModelName();

        Map<String, Long> modelNameToId = modelAPI.modelNamesAndIds(0);
        Long modelId = modelNameToId.get(modelName);

        String selectionQuery = "";
        if (!noteOptions.isCheckAllModels()) {
            selectionQuery = String.format(
                    Locale.US,
                    "%s=%d and ",
                    FlashCardsContract.Note.MID,
                    modelId
            );
        }
        selectionQuery = selectionQuery + String.format(
                Locale.US,
                "%s in (%s)",
                FlashCardsContract.Note.CSUM,
                TextUtils.join(",", checksums)
        );

        final Cursor cursor = context.getContentResolver().query(
                FlashCardsContract.Note.CONTENT_URI_V2,
                NOTE_PROJECTION,
                selectionQuery,
                null,
                null
        );

        if (cursor == null || cursor.getCount() == 0) {
            for (int i = 0; i < notesToTest.size(); i++) {
                canAddNote.add(true);
            }
        }
        else {
            LinkedHashSet<Long> queryChecksums = findChecksumsInQuery(
                    cursor,
                    noteOptions.getDuplicateScope().equals("deck"), deckIds);

            for (int i = 0; i < checksums.size(); i++) {
                boolean isChecksumFound = !queryChecksums.contains(checksums.get(i));
                canAddNote.add(isChecksumFound);
            }
        }

        return canAddNote;
    }

    private LinkedHashSet<Long> findChecksumsInQuery(Cursor cursor, boolean isDuplicateScopeDeck, Set<Long> deckIds) {
        LinkedHashSet<Long> queryChecksums = new LinkedHashSet<>();

        try (cursor) {
            while (cursor.moveToNext()) {
                // Build list of CSUM (queryChecksums)
                // If an entry in queryChecksums is in checksums, then we have a duplicate
                // If scope is "deck", these duplicates need to be checked again for the deck
                int idIdx = cursor.getColumnIndexOrThrow(FlashCardsContract.Note._ID);
                int csumIdx = cursor.getColumnIndexOrThrow(FlashCardsContract.Note.CSUM);

                long queryNid = cursor.getLong(idIdx);
                long queryCsum = cursor.getLong(csumIdx);

                // If duplicate scope is "deck", need an additional query
                if (!isDuplicateScopeDeck || isNoteInDeck(queryNid, deckIds)) {
                    queryChecksums.add(queryCsum);
                }
            }
        }

        return queryChecksums;
    }

    private boolean isNoteInDeck(long noteId, Set<Long> deckIds) {
        // Need to search for all cards with the same note ID, and see if they exist in one of the decks.
        final String[] CARD_PROJECTION = {FlashCardsContract.Card.DECK_ID};

        Uri noteUri = Uri.withAppendedPath(FlashCardsContract.Note.CONTENT_URI, Long.toString(noteId));
        Uri cardUri = Uri.withAppendedPath(noteUri, "cards");
        Cursor cardCursor = context.getContentResolver().query(
                cardUri,
                CARD_PROJECTION,
                null,
                null,
                null
        );

        if(cardCursor != null) {
            try (cardCursor) {
                while(cardCursor.moveToNext()) {
                    int didIdx = cardCursor.getColumnIndexOrThrow(FlashCardsContract.Card.DECK_ID);
                    long did = cardCursor.getLong(didIdx);

                    if (deckIds.contains(did)) {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    public static class CanAddWithError {
        private final boolean canAdd;
        private final String error;

        public CanAddWithError(boolean canAdd, String error) {
            this.canAdd = canAdd;
            this.error = error;
        }

        public boolean isCanAdd() {
            return canAdd;
        }

        public String getError() {
            return error;
        }
    }

    public List<CanAddWithError> canAddNotesWithErrorDetail(ArrayList<NoteRequest> notesToTest) throws Exception {
        List<CanAddWithError> canAddWithErrorList = new ArrayList<>();
        List<Boolean> canAddList = canAddNotes(notesToTest);

        for (boolean canAdd : canAddList) {
            CanAddWithError canAddWithError;
            if (canAdd) {
                canAddWithError = new CanAddWithError(true, null);
            }
            else {
                canAddWithError = new CanAddWithError(false, CAN_ADD_ERROR_REASON);
            }
            canAddWithErrorList.add(canAddWithError);
        }

        return canAddWithErrorList;
    }

    /**
     * Add flashcards to AnkiDroid through instant add API
     * @param data Map of (field name, field value) pairs
     * @return The id of the note added
     */
    public Long addNote(final Map<String, String> data, String deck_name, String model_name, Set<String> tags) throws Exception {
        Long deck_id = deckAPI.getDeckID(deck_name);
        Long model_id = modelAPI.getModelID(model_name, data.size());
        Long note_id = noteAPI.addNote(data, deck_id, model_id, tags);

        if (note_id != null) {
            new Handler(Looper.getMainLooper()).post(() -> Toast.makeText(context, "Card added", Toast.LENGTH_SHORT).show());
            return note_id;
        } else {
            new Handler(Looper.getMainLooper()).post(() -> Toast.makeText(context, "Failed to add card", Toast.LENGTH_SHORT).show());
            throw new Exception("Couldn't add note");
        }
    }

    /**
     * Adds the media to the collection, and updates noteValues
     *
     * @param noteValues Map from field name to field value
     * @param mediaRequests
     * @throws Exception
     */
    public void addMedia(Map<String, String> noteValues, List<MediaRequest> mediaRequests) throws Exception {
        for (MediaRequest media : mediaRequests) {
            // mediaAPI.storeMediaFile() doesn't store as the passed in filename, need to use the returned one
            Optional<byte[]> data = media.getData();
            Optional<String> url = media.getUrl();
            String stored_filename;
            if (data.isPresent()) {
                stored_filename = mediaAPI.storeMediaFile(media.getFilename(), data.get());
            } else if (url.isPresent()) {
                stored_filename = mediaAPI.downloadAndStoreBinaryFile(media.getFilename(), url.get());
            } else {
                throw new Exception("You must provide a \"data\" or \"url\" field. Note that \"path\" is currently not supported on AnkiConnectAndroid.");
            }

            String enclosed_filename = "";
            switch (media.getMediaType()) {
                case AUDIO:
                case VIDEO:
                    enclosed_filename = "[sound:" + stored_filename + "]";
                    break;
                case PICTURE:
                    enclosed_filename = "<img src=\"" + stored_filename + "\">";
                    break;
            }

            for (String field : media.getFields()) {
                String existingValue = noteValues.get(field);

                if (existingValue == null) {
                    noteValues.put(field, enclosed_filename);
                } else {
                    noteValues.put(field, existingValue + enclosed_filename);
                }
            }
        }
    }

    public void updateNoteFields(long note_id, Map<String, String> newFields, ArrayList<MediaRequest> mediaRequests) throws Exception {
        /*
         * updateNoteFields request looks like:
         * id: int,
         * fields: {
         *     field_name: string
         * },
         * audio | video | picture: [
         *     {
         *         data: base64 string,
         *         filename: string,
         *         fields: string[]
         *         + more fields that are currently unsupported
         *      }
         * ]
         *
         * Fields is an incomplete list of fields, and the Anki API expects the the passed in field
         * list to be complete. So, need to get the existing fields and only update them if present
         * in the request. Also need to reverse map each media file back to the field it will be
         * included in and append it enclosed in either <img> or [sound: ]
         */

        String[] modelFieldNames = modelAPI.modelFieldNames(noteAPI.getNoteModelId(note_id));
        String[] originalFields = noteAPI.getNoteFields(note_id);

        // updated fields
        HashMap<String, String> cardFields = new HashMap<>();

        // Get old fields and update values as needed
        for (int i = 0; i < modelFieldNames.length; i++) {
            String fieldName = modelFieldNames[i];

            String newValue = newFields.get(modelFieldNames[i]);
            if (newValue != null) {
                // Update field to new value
                cardFields.put(fieldName, newValue);
                // Ankidroids `getFields` won't return empty fields that are at the end of the array
                // so `originalFields` may potentially contain less fields than `modelFieldNames`
            } else if (originalFields.length >= i + 1) {
                cardFields.put(fieldName, originalFields[i]);
            } else {
                cardFields.put(fieldName, "");
            }
        }

        addMedia(cardFields, mediaRequests);
        noteAPI.updateNoteFields(note_id, cardFields);
    }

    public int deleteNotes(long[] noteIds) {
        if (noteIds == null || noteIds.length == 0) {
            return 0;
        }
        String[] selectionArgs = new String[noteIds.length];
        for (int i = 0; i < noteIds.length; i++) {
            selectionArgs[i] = String.valueOf(noteIds[i]);
        }
        String selection = FlashCardsContract.Note._ID + " IN (" + new String(new char[noteIds.length - 1]).replace("\0", "?,") + "?)";
        return context.getContentResolver().delete(FlashCardsContract.Note.CONTENT_URI, selection, selectionArgs);
    }

    public String storeMediaFile(BinaryFile binaryFile) throws IOException {
        return mediaAPI.storeMediaFile(binaryFile.getFilename(), binaryFile.getData());
    }

    public ArrayList<Long> guiBrowse(String query) {
        // https://github.com/ankidroid/Anki-Android/pull/11899
        Uri webpage = Uri.parse("anki://x-callback-url/browser?search=" + query);
        Intent webIntent = new Intent(Intent.ACTION_VIEW, webpage);
        webIntent.setPackage("com.ichi2.anki");
        // FLAG_ACTIVITY_NEW_TASK is needed in order to display the intent from a different app
        // FLAG_ACTIVITY_CLEAR_TOP and Intent.FLAG_ACTIVITY_TASK_ON_HOME is needed in order to not
        // cause a long chain of activities within Ankidroid
        // (i.e. browser <- word <- browser <- word <- browser <- word)
        // FLAG_ACTIVITY_CLEAR_TOP also allows the browser window to refresh with the new word
        // if AnkiDroid was already on the card browser activity.
        // see: https://stackoverflow.com/a/23874622
        webIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_TASK_ON_HOME);
        context.startActivity(webIntent);

        // The result doesn't seem to be used by Yomichan at all, so it can be safely ignored.
        // If we want to get the results, calling the findNotes() method will likely cause
        // unwanted delay.
        return new ArrayList<>();
    }
}
</file>

<file path="app/build.gradle">
plugins {
    id 'com.android.application'
}

android {
    compileSdk 33

    defaultConfig {
        applicationId "com.kamwithk.ankiconnectandroid"
        minSdk 26
        targetSdk 33
        versionCode 15
        versionName "1.15"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"

        javaCompileOptions {
            annotationProcessorOptions {
                arguments += ["room.schemaLocation": "$projectDir/schemas".toString()]
            }
        }

    }

    signingConfigs {
        release {
            if (System.getenv("SIGNING_KEY_STORE_BASE64") != null) {
                def keyStoreFile = new File(project.rootDir, "release-key.jks")
                def keyStoreBase64 = System.getenv("SIGNING_KEY_STORE_BASE64")
                keyStoreFile.bytes = keyStoreBase64.decodeBase64()

                storeFile keyStoreFile
                storePassword System.getenv("SIGNING_STORE_PASSWORD")
                keyAlias System.getenv("SIGNING_KEY_ALIAS")
                keyPassword System.getenv("SIGNING_KEY_PASSWORD")
            }
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
    }

    dependenciesInfo {
        // Disables dependency metadata when building APKs.
        includeInApk = false
        // Disables dependency metadata when building Android App Bundles.
        includeInBundle = false
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_9
        targetCompatibility JavaVersion.VERSION_1_9
    }
    namespace 'com.kamwithk.ankiconnectandroid'
}

dependencies {

    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'androidx.core:core:1.9.0'
    implementation 'com.google.android.material:material:1.8.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
    implementation 'com.google.code.gson:gson:2.9.0'
    implementation 'org.nanohttpd:nanohttpd:2.3.1'
    implementation 'org.nanohttpd:nanohttpd-nanolets:2.3.1'
    implementation 'com.github.ankidroid:Anki-Android:2.17alpha14'
    implementation 'org.jsoup:jsoup:1.14.3'
    implementation 'androidx.preference:preference:1.2.0'

    def room_version = "2.5.0"
    implementation "androidx.room:room-runtime:$room_version"
    annotationProcessor "androidx.room:room-compiler:$room_version"


    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
}
</file>

<file path="app/src/main/java/com/kamwithk/ankiconnectandroid/routing/LocalAudioAPIRouting.java">
package com.kamwithk.ankiconnectandroid.routing;

import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;

import android.content.Context;
import android.util.Log;

import androidx.room.Room;
import androidx.sqlite.db.SimpleSQLiteQuery;

import com.google.gson.JsonObject;
import com.google.gson.reflect.TypeToken;
import com.kamwithk.ankiconnectandroid.request_parsers.Parser;
import com.kamwithk.ankiconnectandroid.routing.database.AudioFileEntryDao;
import com.kamwithk.ankiconnectandroid.routing.database.EntriesDatabase;
import com.kamwithk.ankiconnectandroid.routing.database.Entry;
import com.kamwithk.ankiconnectandroid.routing.database.EntryDao;
import com.kamwithk.ankiconnectandroid.routing.localaudiosource.ForvoAudioSource;
import com.kamwithk.ankiconnectandroid.routing.localaudiosource.JPodAltAudioSource;
import com.kamwithk.ankiconnectandroid.routing.localaudiosource.JPodAudioSource;
import com.kamwithk.ankiconnectandroid.routing.localaudiosource.LocalAudioSource;
import com.kamwithk.ankiconnectandroid.routing.localaudiosource.NHK16AudioSource;
import com.kamwithk.ankiconnectandroid.routing.localaudiosource.Shinmeikai8AudioSource;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import fi.iki.elonen.NanoHTTPD;

/**
 * Local audio in AnkidroidAndroid works similarly to the original python script found at
 * https://github.com/Aquafina-water-bottle/jmdict-english-yomichan/tree/master/local_audio
 *
 * Here are the main differences:
 * - The memory-based version is not supported. Only the SQL version is supported.
 * - The SQLite3 database is *NOT* dynamically created. This means that the user must copy/paste
 *   the generated entries.db into the correct place within their Android device. The database
 *   is not created dynamically in order to make the process of implementing this feature
 *   as simple as possible.
 * - The URIs are different:
 *   - initial get:
 *     python:  http://localhost:5050/?sources=jpod,jpod_alternate,nhk16,forvo&term={term}&reading={reading}
 *     android: http://localhost:8765/localaudio/get/&sources=jpod,jpod_alternate,nhk16,forvo&term={term}&reading={reading}
 *   - audio file get:
 *     python:  http://localhost:5050/SOURCE/FILE_PATH_TO_AUDIO_FILE
 *     android: http://localhost:8765/localaudio/SOURCE/FILE_PATH_TO_AUDIO_FILE
 *  - NHK98 is not supported (because the audio files aren't available for the original anyways)
 */
public class LocalAudioAPIRouting {
    private final Context context;

    // sourceIdToSource is a LinkedHashMap to preserve insertion order
    private final LinkedHashMap<String, LocalAudioSource> sourceIdToSource;

    public LocalAudioAPIRouting(Context context) {
        this.context = context;

        // TODO: read config
        this.sourceIdToSource = new LinkedHashMap<>();
        this.sourceIdToSource.put("nhk16", new NHK16AudioSource());
        this.sourceIdToSource.put("shinmeikai8", new Shinmeikai8AudioSource());
        this.sourceIdToSource.put("forvo", new ForvoAudioSource());
        this.sourceIdToSource.put("jpod", new JPodAudioSource());
        this.sourceIdToSource.put("jpod_alternate", new JPodAltAudioSource());
    }

    private EntriesDatabase getDB() {
        // TODO global instance?
        File databasePath = new File(context.getExternalFilesDir(null), "android.db");
        EntriesDatabase db = Room.databaseBuilder(context,
                EntriesDatabase.class, databasePath.toString()).build();
        return db;
    }

    public NanoHTTPD.Response getAudioSourcesHandleError(Map<String, List<String>> parameters) {

        String term = getTerm(parameters);
        String reading = getReading(parameters);
        List<String> sources = getSources(parameters);
        List<String> users = getUser(parameters);

        List<Map<String, String>> audioSourcesResult = new ArrayList<>();
        List<String> args = new ArrayList<>();


        // opens database (creates if doesn't exist)
        EntriesDatabase db = getDB();
        EntryDao entryDao = db.entryDao();

        // query generator based off of the original plugin:
        // https://github.com/Aquafina-water-bottle/local-audio-yomichan/blob/master/plugin/db_utils.py
        // Filter results WHERE "title" = 'My Title'
        String selection = "expression = ?\n" +
                "AND (reading IS NULL OR reading = ?)\n";
        args.add(term);
        args.add(reading);

        // filters by sources if necessary
        if (sources.size() != sourceIdToSource.size()) {
            String nQuestionMarks = String.join(",", Collections.nCopies(sources.size(), "?"));
            selection += "AND (source in (" + nQuestionMarks + "))\n";
            args.addAll(sources);
        }

        // filters by speakers if necessary
        if (users.size() > 0) {
            String nQuestionMarks = String.join(",", Collections.nCopies(users.size(), "?"));
            selection += "AND (speaker IS NULL or speaker in (" + nQuestionMarks + "))\n";
            args.addAll(users);
        }

        // How you want the results sorted in the resulting Cursor
        // order by source
        StringBuilder sortOrder = new StringBuilder("(CASE source ");
        for (int i = 0; i < sources.size(); i++) {
            sortOrder.append("WHEN ? THEN ").append(i).append("\n");
            args.add(sources.get(i));
        }
        sortOrder.append(" END)\n");

        // order by speakers if necessary
        if (users.size() > 0) {
            sortOrder.append(", (CASE speaker ");
            for (int i = 0; i < users.size(); i++) {
                sortOrder.append("WHEN ? THEN ").append(i).append("\n");
                args.add(users.get(i));
            }
            sortOrder.append(" END)\n");
        }

        String queryString = "\n" +
                "SELECT * FROM entries WHERE (" + selection + ")\n" +
                "ORDER BY " + sortOrder + ", reading;";

        SimpleSQLiteQuery query = new SimpleSQLiteQuery(queryString, args.toArray());
        List<Entry> entries = entryDao.getSources(query);

        for (Entry entry : entries) {
            String source = entry.source;
            String file = entry.file;

            LocalAudioSource audioSource = sourceIdToSource.get(entry.source);
            if (audioSource == null) {
                Log.w("AnkiConnectAndroid", "Unknown audio source: " + source);
                continue;
            }

            String name = audioSource.getSourceName(entry);
            String url = audioSource.constructFileURL(file);

            Map<String, String> audioSourceEntry = new HashMap<>();
            audioSourceEntry.put("name", name);
            audioSourceEntry.put("url", url);

            audioSourcesResult.add(audioSourceEntry);
        }

        Type typeToken = new TypeToken<ArrayList<HashMap<String, String>>>() {}.getType();

        JsonObject response = new JsonObject();
        response.addProperty("type", "audioSourceList");
        response.add("audioSources", Parser.gson.toJsonTree(audioSourcesResult, typeToken));
        Log.d("AnkiConnectAndroid", "audio sources json: " + Parser.gson.toJson(response));

        return newFixedLengthResponse(
                NanoHTTPD.Response.Status.OK,
                "text/json",
                Parser.gson.toJson(response)
        );
    }

    private NanoHTTPD.Response audioError(String msg) {
        Log.w("AnkiConnectAndroid", msg);
        return newFixedLengthResponse(
                NanoHTTPD.Response.Status.BAD_REQUEST, // 400, mimics python script
                NanoHTTPD.MIME_PLAINTEXT, msg
        );
    }

    private String getTerm(Map<String, List<String>> parameters) {
        try {
            return parameters.get("term").get(0);
        } catch (NullPointerException e) {
            return parameters.get("expression").get(0);
        }
    }

    private String getReading(Map<String, List<String>> parameters) {
        return Objects.requireNonNull(parameters.get("reading")).get(0);
    }

    private List<String> getUser(Map<String, List<String>> parameters) {
        List<String> _user = parameters.get("user");
        List<String> users = new ArrayList<>();
        if (_user != null && _user.size() > 0) {
            users = List.of(_user.get(0).split(","));
        }
        return users;
    }

    private List<String> getSources(Map<String, List<String>> parameters) {
        List<String> sources = parameters.get("sources");
        if (sources != null && sources.size() == 1) {
            return List.of(sources.get(0).split(","));
        }

        // default order
        return new ArrayList<>(sourceIdToSource.keySet());
    }

    public NanoHTTPD.Response getAudioHandleError(String source, String path) {
        if (!sourceIdToSource.containsKey(source)) {
            return audioError("Unknown source: " + source);
        }

        EntriesDatabase db = getDB();
        AudioFileEntryDao audioFileEntryDao = db.audioFileEntryDao();

        String pathDecoded = path;
        try {
            pathDecoded = URLDecoder.decode(pathDecoded, "UTF-8");
        }
        catch (UnsupportedEncodingException ignored) {
        }

        byte[] data = audioFileEntryDao.getData(pathDecoded, source);

        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
        String mimeType = null;
        if (path.endsWith(".mp3")) {
            mimeType = "audio/mpeg";
        } else if (path.endsWith(".aac")) {
            mimeType = "audio/aac";
        } else if (path.endsWith(".m4a")) {
            mimeType = "audio/mp4";
        } else if (path.endsWith(".ogg") || path.endsWith(".oga") || path.endsWith(".opus")) {
            mimeType = "audio/ogg";
        } else if (path.endsWith(".flac")) {
            mimeType = "audio/flac";
        } else if (path.endsWith(".wav")) {
            mimeType = "audio/wav";
        }
        if (mimeType == null) {
            return audioError("File is not a supported audio file: " + path);
        }
        return newFixedLengthResponse(NanoHTTPD.Response.Status.OK, mimeType, new ByteArrayInputStream(data), data.length);

    }
}
</file>

<file path="README.md">
# Ankiconnect Android

Ankiconnect Android allows you to utilize the standard Anki mining workflow on Android devices like phones and eReaders.
Create Anki cards using [Yomitan](https://yomitan.wiki/) on [Firefox Browser](https://play.google.com/store/apps/details?id=org.mozilla.firefox) and add them straight into your Anki deck!
Mine on the go in the same way as you mine on your desktop pc.
Forvo and local audio are now supported!


Ankiconnect Android is a from scratch unofficial reimplementation of the [desktop Ankiconnect extension](https://github.com/FooSoft/anki-connect), [desktop Forvo Server extension](https://github.com/jamesnicolas/yomichan-forvo-server) and [desktop Local Audio Server for Yomitan](https://github.com/themoeway/local-audio-yomichan).
It reimplements the core APIs used by Yomitan to work with [Ankidroid](https://github.com/ankidroid/Anki-Android/).

## Table of Contents
- [Ankiconnect Android](#ankiconnect-android)
  - [Table of Contents](#table-of-contents)
  - [Instructions](#instructions)
    - [Additional Instructions: Forvo Audio](#additional-instructions-forvo-audio)
    - [Additional Instructions: Show Card Button](#additional-instructions-show-card-button)
    - [Additional Instructions: Local Audio](#additional-instructions-local-audio)
  - [Common Errors and Solutions](#common-errors-and-solutions)
    - [First Steps](#first-steps)
    - [Problem: The Yomitan popup appears upon scrolling](#problem-the-yomitan-popup-appears-upon-scrolling)
    - [Problem: The add button is always greyed out](#problem-the-add-button-is-always-greyed-out)
    - [Problem: The add card button does not appear](#problem-the-add-card-button-does-not-appear)
    - [Problem: Duplicate checks aren't working](#problem-duplicate-checks-arent-working)
    - [Problem: Forvo audio won't load](#problem-forvo-audio-wont-load)
    - [Problem: On card add, I get `Incorrect flds argument`](#problem-on-card-add-i-get-incorrect-flds-argument)
    - [I still have a problem](#i-still-have-a-problem)
  - [Limitations](#limitations)
  - [Developer Info](#developer-info)
  - [Contributing](#contributing)

## Instructions
Here's how to set everything up from scratch (if you've already got Yomitan working, then skip to step 5):

1. Install [Firefox Browser](https://play.google.com/store/apps/details?id=org.mozilla.firefox)
2. Install [Ankidroid](https://play.google.com/store/apps/details?id=com.ichi2.anki)
3. Install Ankiconnect Android - Download from the [Releases Section](https://github.com/KamWithK/AnkiconnectAndroid/releases/latest) or from [IzzyOnDroid repo](https://apt.izzysoft.de/fdroid/index/apk/com.kamwithk.ankiconnectandroid)
4. Start the Ankiconnect Android app, accept the permissions and hit start service
5. Install the [Yomitan extension](https://addons.mozilla.org/en-US/firefox/addon/yomitan/) in Firefox Browser
6. Configure Yomitan general settings
    1. Ensure advanced settings is enabled (button at the bottom right corner)
    2. Dictionaries: `Import` 1+ dictionaries by clicking `Configure installed and enabled dictionaries` and then `Import` under `Dictionaries` section ([external resources](https://learnjapanese.moe/resources/#dictionaries))
    3. General: It is recommended to lower the value of `Maximum number of results` to prevent unnecessary lag. A sane value would be `8`
7. Configure Yomitan Scanning settings
    1. Scanning: `Scan delay` can feel laggy and so can be set to `0`
    2. Scanning: Navigate to `Scanning` → `Configure advanced scanning inputs`
        1. Ensure that advanced options within the `Scanning Inputs` window is enabled. To do this, scroll to the right, and tap on the three dots.
        2.   <details> <summary>For Yomitan, use the defaults or match your settings to be like this image: <i>(click here)</i></summary>
            <a href="./img/scanning_inputs_yomitan.png"><img src="./img/scanning_inputs_yomitan.png" width="400" /></a>
            </details>
        3. Navigate to `Scanning` → `Support inputs for devices with touch screens`
            * Ensure that `Touch inputs` is checked, and `Pointer inputs` is NOT checked.
    3. Scanning: If you are studying Japanese/Chinese and don't want to popup to appear on any other languages disable  `Search text with non-Japanese, Chinese, or Cantonese characters`.
8. Configure Yomitan Anki settings
    1. Anki: Toggle `Enable Anki integration` on
    2. Anki: Click on `Configure Anki card format` and choose the deck, model and field/values you desire. *(For further customization you can write/modify the script under `Configure Anki card templates`)*
    3. Anki: Ensure `Show Card Tags` is set to "Never"

> Easier Yomitan setup: If you import settings from a computer, ensure that step 7 and step 8.3 are still followed

### Additional Instructions: Forvo Audio
The default audio sources from Yomitan should already work.
However, Forvo can be added as an audio source.
It is recommended that you add this Forvo audio source
because Forvo significantly extends the coverage of audio
compared to the default audio sources from Yomitan.

1. Click on `Configure audio playback sources` and under the `Audio` section
2. Click the `Add` button (top right corner)
3. **Select `Custom URL (JSON)` and copy paste the following into the `URL` box**:

    ```
    http://localhost:8765/?term={term}&reading={reading}
    ```

    NOTE: This is NOT the same URL as from your PC, the port is different



### Additional Instructions: Show Card Button
By default, the show card button **will not work**.
The following is a *completely optional* set of instructions for getting the show card button to work:

1. Install a **pre-release (alpha) version** of AnkiDroid from their [releases page](https://github.com/ankidroid/Anki-Android/releases). This cannot be a parallel build.
    * As of writing this (2023/01/03), the stable release of AnkiDroid
        (i.e. the released version on Google Play) does not support the feature of
        [opening the card browser window](https://github.com/ankidroid/Anki-Android/pull/11899)
        from another app. Therefore, the first step is to manually download and install
        the most recent alpha version of AnkiDroid.
    * This carries all the risks of using a pre-release version! Only download it
        if you know what you are doing.

2. After installing AnkiDroid, you must allow Ankiconnect Android to open apps in the background.
    * Under Ankiconnect Android, tap on the settings gear at the top right corner.
    * Tap on the `Access Overlay Permissions` option. This should lead you to Android's settings page.
    * Activate the switch for `Ankiconnect Android` within this settings page.

From here, you should be able to use the show card button as normal.

> **Warning**:
> Make sure you save your note changes if you edit your note! If you do not
> save your changes and re-click on the "show card" button from Firefox Browser, you will
> lose all your current note changes!

### Additional Instructions: Local Audio
The [(desktop) local audio server](https://github.com/themoeway/local-audio-yomichan)
setup for Yomitan has been ported over to Ankiconnect Android, and can be used similarly.
Again, this is *a completely optional* setup that does not need to be done.

General information about the setup, including reasons for and against using the setup,
can be found within the above link.

> **Warning**:
> This setup takes up about 5gb of space on your Android device! Ensure you have enough space before setting this up.

1. Ensure you have set up the latest version of the [desktop local audio server](https://github.com/themoeway/local-audio-yomichan) setup.
    If you already have the add-on installed, check for updates by navigating to `Tools` → `Add-ons` → (select "Local Audio Server for Yomitan") → `Check for Updates`.

2. Generate the Android database.

    > **Note**:
    > For Windows users, please temporarily disable Windows defender before doing this step.
    > It seems like generating the Android database with Windows Defender enabled can slow it
    > down by a factor of 6, meaning a step that should only take 5 minutes
    > can easily take over half an hour.

    To generate the database, navigate to (Anki) → `Tools` (top left corner) → `Local Audio Server` → `Generate Android database`. Expect this to take a while (at least a few minutes).

    <details> <summary>Example Image <i>(click here)</i></summary>

    ![generate android database](./img/gen_android_db.png)

    </details>

    This database stores all the audio files into one large file, in order to make file transfer to Android much faster (transferring the folder took about 24 hours, while transferring the large file took less than 3 minutes).

3. Copy the files from desktop to Android.
    * Locate the add-on folder on desktop.
        To do this, navigate to `Tools` → `Add-ons` → (select "Local Audio Server for Yomitan") → `View Files`.
        When you are here, navigate to `user_files`.

    * Locate AnkiConnect Android's data folder. By default, it is under:
        ```
        (phone)/Android/data/com.kamwithk.ankiconnectandroid/files/
        ```
        However, one can verify the location of the folder by going into the settings
        (gear at the top right corner), and tapping on `Print Local Audio Directory`.
        The following output specifies that the folder is indeed in the default position:
        ```
        /storage/emulated/0/Android/data/com.kamwithk.ankiconnectandroid/files/
        ```

    * After locating the two folders, copy `android.db` from the desktop's add-on folder
        into Ankiconnect Android's data folder.
        * If you have a previous `android.db`, please delete this file and any related files (i.e. delete `android.db-shm` and `android.db-wa`)
        * Ensure AnkiConnectAndroid is fully closed before copying the database, because
            AnkiConnectAndroid may override the new database if it is open.
            If you want to be 100% sure that the app is closed, you can restart your device.
        * Do NOT copy the entire `user_files` folder.
        * After copying the file, this should result in the following:
            ```
            /storage/emulated/0/Android/data/com.kamwithk.ankiconnectandroid/files/android.db
            ```

4. Setup local audio on Firefox Browser's Yomitan. (Warning: this URL is different than the one on desktop!)
    * Click on `Configure audio playback sources` and under the `Audio` section
    * Click the `Add` button (top right corner)
    * Select `Custom URL (JSON)` and copy paste the following into the `url` box (tap the code box, and then tap the button to the right to copy the text to the clipboard):
        ```
        http://localhost:8765/localaudio/get/?term={term}&reading={reading}
        ```

        * The `sources` and `user` parameters should behave exactly like the desktop local audio plugin.

            <details>
            <summary>Example, with sources in the default order <i>(click here)</i></summary>

            ```
            http://localhost:8765/localaudio/get/?term={term}&reading={reading}&sources=nhk16,shinmeikai8,forvo,jpod,jpod_alternate
            ```

            </details>


5. Ensure it works.
    * You can do the
        [exact same check](https://github.com/themoeway/local-audio-yomichan#steps)
        as the desktop local audio server (the last step),
        by scanning 読む and checking that all sources appear.
        Be sure to play all of the sources to ensure that the audio is properly fetched.


## Common Errors and Solutions

### First Steps
If you are having issues with anything, such as Yomitan being unable to connect to AnkiDroid, please ensure all these steps are followed before continuing:

* Make sure the latest [app release](https://github.com/KamWithK/AnkiconnectAndroid/releases/latest) is installed.
* If you imported the settings from the PC, try to use the sanitized version upon import, and manually re-add the handlebars after.
* Double check that your Yomitan settings are correct. In particular, check that the `Configure Anki card format...` section, and the audio sources section is correct.
    * On rare occasions, settings exported from the computer and imported into your Android device may not work. Instead, try to reset Yomitan's settings and redo everything from scratch.
* Battery saving/automatic optimisation is turned off for Ankidroid, Ankiconnect Android and optionally (but recommended) Firefox browser.
* You allowed Ankiconnect Android to be running in the background (if this option is available on your device).


### Problem: The Yomitan popup appears upon scrolling
Try going through step 5 of the [instructions](#instructions).
In particular, see the step that says
**Ensure `Scanning Inputs` is optimized for mobile (prevents lookups on scrolling)**.


### Problem: The add button is always greyed out
This usually happens if `Enable Content Scanning` is switched off.
To fix this, simply switch it on (under `Yomitan Settings` → `General` → `Enable content scanning`).

> **Note**:
> If you have this switched off in the first place, it is also very likely that the popup is
> showing up at unwanted times, i.e. while scrolling through a page.
> To solve this, try going through step 5 of the [instructions](#instructions).


### Problem: The add card button does not appear
- Check that the `Enable Anki integration` setting in Yomitan is indeed enabled, and properly connected.
- Under `Anki` → `Configure Anki card format`, ensure that the Deck and Model at the top right corner
    are not highlighted in red. If they are, please select the correct deck and/or model.
- Under `Anki` → `Show card tags`, make sure this is set to `Never`.


### Problem: Duplicate checks aren't working
To determine that duplicate checks aren't working:
- Enable duplicate checks in the Yomitan settings (under `Anki` → `Check for card duplicates`),
- Select a word and add a card
- Tap outside of the popup, and re-select the word. Normally, you should not be able to add a card here.

If you are able to add a card (i.e. you see the plus button), then duplicate checks are indeed not working.
Check that your first field name does not include spaces,
and your first field contents do not include quotes (`"`) or spaces.
If either of those are true, the only way to solve it is by using the Alpha version of AnkiDroid, and
[enable the new backend](https://github.com/ankidroid/Anki-Android/issues/13399)
under the advanced settings.


### Problem: Forvo audio won't load
Please make sure that this exact URL under
[Additional Instructions: Forvo Audio](#additional-instructions-forvo-audio) is used.
This URL is different from the one on PC.

> **Note**:
> There is always a chance that Forvo has changed the layout of their website,
> which can lead to AnkiConnect Android improperly fetching the audio.
> If you suspect this is the case, please create an issue on Github.


### Problem: On card add, I get `Incorrect flds argument`
This happens when you change the fields of a card. For example, if you added a field,
renamed a field, or deleted a field, then this error may pop up.
To fix it, navigate to `Yomitan Settings` → `Anki` →  `Configure Anki card format...`,
and update the model fields (i.e. by switching it to a different model and back).


### I still have a problem
If you've gone through the instructions and are still having trouble, feel free to create an issue here on GitHub or @/dm me on Discord (`@KamWithK#0634` on [TheMoeWay](https://learnjapanese.moe/join/)). Most related discussions happen in [the AnkiConnect Android thread](https://discord.com/channels/617136488840429598/1060781077955887195).



## Limitations
Because Ankiconnect Android is a small project with a limited scope, not all API queries/cases are implemented/considered.
Currently every known essential feature has been added into the app, however some niche edge cases have been ignored.

Some examples:
1. Duplicate checks always occur across the full Anki collection instead of whatever deck is selected (no matter what options are selected, assuming this feature is left enabled)
2. The show card button will not work on the latest stable release of AnkiDroid. Instead, you must **manually install a pre-release version of AnkiDroid** for it to work. Please see [these instructions](#additional-instructions-show-card-button) for more details on how to make the show card button work.
3. When viewing the note, the note cannot be viewed directly within card editor. Instead, the note is shown from the card search screen.
4. You are unable to view the note tags on duplicate notes.


## Developer Info
For developers who are interested in using the API, please see [docs/api.md](./docs/api.md) for a list of all supported API calls.

## Contributing
The primary goal of Ankiconnect Android was to support card creation with Yomitan.
Therefore, many API calls are not implemented.
In the spirit of
[Anki-Connect itself](https://github.com/FooSoft/anki-connect#hey-could-you-add-a-new-action-to-support-feature),
this *project operates on a self-serve model*.
Feature requests will not be serviced.

If you would like a new API call, make a PR with the following criteria:
* Ensure that your API call matches an [existing Anki-Connect action](https://github.com/FooSoft/anki-connect#supported-actions). New actions, or outward modifications to existing actions (i.e. new input parameters) will not be accepted.
    * Note: your API call does not have to have the full capability that Anki-Connect provides, so long as
        it is documented (see the second point below).
* Add the relevant documentation to [docs/api.md](./docs/api.md), including any edge cases and
    important implementation details.
* Attempt to match the code style of the project.
</file>

</files>
